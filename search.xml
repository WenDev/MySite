<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>506.相对名次</title>
      <link href="/2021/12/02/506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/"/>
      <url>/2021/12/02/506-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a>506. 相对名次</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/relative-ranks">506. 相对名次</a></p><h2 id="解法：排序-哈希表"><a href="#解法：排序-哈希表" class="headerlink" title="解法：排序+哈希表"></a>解法：排序+哈希表</h2><p>本题的核心思想比较简单，由于分数互不相同，所以只需要一次倒序排序就可以获得所有运动员的相对名次。但是由于排序之后数据元素的下标会发生变化，所以我们还需要用哈希表存储数组中元素原来的下标，并且在计算答案时要根据哈希表中存储的元素的原有下标将其对应的名次放入答案数组的相应位置。</p><p>本题的关键在于实现倒序排序，在Golang中可以使用<code>sort.Sort()</code>函数配合<code>sort.Reverse()</code>函数来完成。</p><pre><code class="go">import (    &quot;sort&quot;    &quot;fmt&quot;)func findRelativeRanks(score []int) []string &#123;    m := make(map[int]int)    for i, s := range score &#123;        m[s] = i    &#125;    sort.Sort(sort.Reverse(sort.IntSlice(score)))    ans := make([]string, len(score))    for i, r := range score &#123;        if i == 0 &#123;            ans[m[r]] = &quot;Gold Medal&quot;        &#125; else if i == 1 &#123;            ans[m[r]] = &quot;Silver Medal&quot;        &#125; else if i == 2 &#123;            ans[m[r]] = &quot;Bronze Medal&quot;        &#125; else &#123;            ans[m[r]] = fmt.Sprintf(&quot;%d&quot;, i+1)        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时：16 ms, 在所有 Go 提交中击败了24.75%的用户；</p><p>内存消耗：6.8 MB, 在所有 Go 提交中击败了5.94%的用户；</p><p>时间复杂度：O(nlogn)，来自排序算法；</p><p>空间复杂度：O(n)，哈希表的长度为数组的长度。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.买卖股票的最佳时机</title>
      <link href="/2021/12/01/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2021/12/01/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">121. 买卖股票的最佳时机</a></p><h2 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h2><p>本题也可以使用暴力算法枚举所有购买方法的最大利润，但本题的动态规划解法并不难。</p><p>状态转移方程：第i天的最大利润 = max(第i天的价格 - 前i天的最小价格，前i-1天的最大利润)，在实现上只需要使用两个变量记录前i天的最大利润和前i天的最小价格，然后按照状态转移方程进行递推即可。</p><pre><code class="go">func maxProfit(prices []int) int &#123;    // 第i天的最大收益 = max(第i天的价格 - 前i天的最小价格, 前i-1天的最大收益)    maxIncome := 0    minPrice := prices[0]    for i := 1; i &lt; len(prices); i++ &#123;        if prices[i] - minPrice &gt; maxIncome &#123;            maxIncome = prices[i] - minPrice        &#125;         if prices[i] &lt; minPrice &#123;            minPrice = prices[i]        &#125;    &#125;    return maxIncome&#125;</code></pre><p>执行用时：152 ms, 在所有 Go 提交中击败了11.56%的用户；</p><p>内存消耗：8.1 MB, 在所有 Go 提交中击败了56.62%的用户；</p><p>时间复杂度：O(n)，需要遍历price数组一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350.两个数组的交集</title>
      <link href="/2021/12/01/350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>/2021/12/01/350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350. 两个数组的交集"></a>350. 两个数组的交集</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">350. 两个数组的交集</a></p><h2 id="解法1：哈希表（最简单）"><a href="#解法1：哈希表（最简单）" class="headerlink" title="解法1：哈希表（最简单）"></a>解法1：哈希表（最简单）</h2><p>遇到这类需要求元素个数的问题一般都可以使用哈希表来解决。分别遍历两个数组，使用两个哈希表来记录某一数据元素在某个数组中的出现次数，然后遍历哈希表，如果某个key在两个哈希表中都出现过，那么说明该数据元素在交集中，将数据元素以出现次数较少的次数放入结果集合中（例如数据元素2在数组1中出现了3次，在数组2中出现了4次，那么需要在结果集合中放入3个2）。</p><pre><code class="go">func intersect(nums1 []int, nums2 []int) []int &#123;    // 哈希表    m1, m2 := make(map[int]int), make(map[int]int)    for _, v := range nums1 &#123;        if _, ok := m1[v]; !ok &#123;            m1[v] = 1        &#125; else &#123;            m1[v]++        &#125;    &#125;    for _, v := range nums2 &#123;        if _, ok := m2[v]; !ok &#123;            m2[v] = 1        &#125; else &#123;            m2[v]++        &#125;    &#125;    ans := make([]int, 0)    for k, v1 := range m1 &#123;        if v2, ok := m2[k]; ok &#123;            less := v1            if v2 &lt; less &#123;                less = v2            &#125;            for i := 0; i &lt; less; i++ &#123;                ans = append(ans, k)            &#125;        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了76.50%的用户；</p><p>内存消耗：3.5 MB, 在所有 Go 提交中击败了5.55%的用户；</p><p>时间复杂度：O(m+n)，需要遍历两个数组各一次；</p><p>空间复杂度：O(m+n)，哈希表占用的内存空间与两个数组中的数据元素种类有关。</p><p>优化思路：这种解法可以只对较短的数组建立哈希表，将空间复杂度优化到O(min(m, n))，这时在遍历较长数组时，每次遇到一个在哈希表中出现过的元素，就把这个元素加入到返回值中，再把哈希表中对应元素的出现次数减1。这种方法的代码如下：</p><pre><code class="go">func intersect(nums1 []int, nums2 []int) []int &#123;    if len(nums1) &gt; len(nums2) &#123;        return doIntersect(nums2, nums1)    &#125;    return doIntersect(nums1, nums2)&#125;func doIntersect(short, long []int) []int &#123;    m := make(map[int]int)    for _, v := range short &#123;        if _, ok := m[v]; !ok &#123;            m[v] = 1        &#125; else &#123;            m[v]++        &#125;    &#125;    ans := make([]int, 0)    for _, v := range long &#123;        if m[v] &gt; 0 &#123;            ans = append(ans, v)            m[v]--        &#125;    &#125;    return ans&#125;</code></pre><h2 id="解法2：原地排序-双指针（效率更高）"><a href="#解法2：原地排序-双指针（效率更高）" class="headerlink" title="解法2：原地排序+双指针（效率更高）"></a>解法2：原地排序+双指针（效率更高）</h2><p>如果需要将空间复杂度优化到O(1)，可以使用空间复杂度为O(1)的原地排序算法将两个数组排好序之后使用双指针进行计数。使用<code>p1</code>和<code>p2</code>分别指向<code>nums1</code>和<code>nums2</code>的头部，当两个指针指向的元素相同时将这个元素加入答案中，并且让两个指针都向前一步；当<code>p1</code>指向的数据元素小于<code>p2</code>指向的数据元素时，说明p1应指向更大的元素，让p1向前走一步，反之让p2向前走一步，直到两个指针越界为止。</p><pre><code class="go">import &quot;sort&quot;func intersect(nums1 []int, nums2 []int) []int &#123;    // 排序+双指针    sort.Ints(nums1)    sort.Ints(nums2)    p1, p2 := 0, 0    ans := make([]int, 0)    for p1 &lt; len(nums1) &amp;&amp; p2 &lt; len(nums2) &#123;        if nums1[p1] == nums2[p2] &#123;            ans = append(ans, nums1[p1])            p1++            p2++        &#125; else if nums1[p1] &lt; nums2[p2] &#123;            p1++        &#125; else &#123; // nums1[p1] &gt; nums2[p2]            p2++        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了76.50%的用户；</p><p>内存消耗：2.8 MB, 在所有 Go 提交中击败了97.95%的用户；</p><p>时间复杂度：O(m+n)，需要遍历两个数组各一次；</p><p>空间复杂度：O(logn)，来自排序算法，若使用原地排序算法，则空间复杂度为O(1)，这里忽略了返回值所占用的空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1446.连续字符</title>
      <link href="/2021/12/01/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6/"/>
      <url>/2021/12/01/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446. 连续字符"></a>1446. 连续字符</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/consecutive-characters">1446. 连续字符</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>这道题是一道很简单的双指针模拟题，但是它也是其他一些问题（例如排序之后进行连续相同元素数量的计数操作）的基础。使用一个指针<code>i</code>从字符串的第2个字符开始遍历字符串，另一个指针<code>start</code>指向相同字符的起点位置，这时，相同字符的个数即为<code>i - start + 1</code>。如果在遍历中发现<code>s[i] != s[i-1]</code>即当前遍历到的元素和上一个元素不相同，这时将<code>start</code>指向<code>i</code>表示开始计算一个新元素的连续长度。 使用另一个变量<code>max</code>保存最大相同字符的个数，遍历时如果发现当前相同元素的个数大于<code>max</code>，则更新<code>max</code>。</p><pre><code class="go">func maxPower(s string) int &#123;    start := 0    max := 1    for i := 1; i &lt; len(s); i++ &#123;        if s[i] != s[i-1] &#123;            start = i        &#125;        if i - start + 1 &gt; max &#123;            max = i - start + 1        &#125;    &#125;    return max&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了10.00%的用户；</p><p>内存消耗：2.3 MB, 在所有 Go 提交中击败了100.00%的用户；</p><p>时间复杂度：O(n)，需要遍历字符串一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>733.图像渲染</title>
      <link href="/2021/11/30/733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2021/11/30/733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a>733. 图像渲染</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/flood-fill/submissions/">733. 图像渲染</a></p><h2 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h2><p>首先将起点更改颜色后入队，然后当队列不空时，每次将一个像素点出队，然后将其周围的四个像素点更改颜色并入队（注意边界条件的判断，只有在图像范围内的像素点才能入队），队列为空时算法结束。</p><pre><code class="go">// r,c代表与当前像素点相邻的四个像素点与当前像素点的坐标之差var (    r = []int&#123;1, 0, 0, -1&#125;    c = []int&#123;0, -1, 1, 0&#125;)type pixel struct &#123;    r, c int&#125;func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;    curColor := image[sr][sc]    if curColor == newColor &#123;        return image    &#125;    // 得到图像的宽和高    w, h := len(image[0]), len(image)    queue := make([]pixel, 0)    // 将像素的初始位置更改颜色并加入队列    queue = append(queue, pixel&#123;r: sr, c: sc&#125;)    image[sr][sc] = newColor    // 开始BFS算法    for len(queue) &gt; 0 &#123;        // 每次将一个像素点出队        p := queue[len(queue)-1]        queue = queue[:len(queue)-1]        // 处理该像素相邻的四个像素点        for i := 0; i &lt; 4; i++ &#123;            rr, cc := p.r + r[i], p.c + c[i]            if rr &gt;= 0 &amp;&amp; cc &gt;= 0 &amp;&amp; rr &lt; h &amp;&amp; cc &lt; w &amp;&amp; image[rr][cc] == curColor &#123;                queue = append(queue, pixel&#123;r: rr, c: cc&#125;)                image[rr][cc] = newColor            &#125;        &#125;    &#125;    return image&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了96.64%的用户</p><p>内存消耗：4.2 MB, 在所有 Go 提交中击败了31.90%的用户</p><p>时间复杂度：O(m * n)，二维数组中的每一个位置（像素）都会被访问一次；</p><p>空间复杂度：O(m * n)，来自队列。</p><h2 id="解法2：DFS"><a href="#解法2：DFS" class="headerlink" title="解法2：DFS"></a>解法2：DFS</h2><p>本题同样可以使用DFS来解。首先使用变量curColor保存当前位置的颜色，然后进行DFS操作。每搜索到一个像素时，如果其颜色与curColor相同，就将其更新为newColor，然后再对其相邻的四个方格递归地进行渲染操作。</p><pre><code class="go">// r,c代表与当前像素点相邻的四个像素点与当前像素点的坐标之差var (    r = []int&#123;1, 0, 0, -1&#125;    c = []int&#123;0, -1, 1, 0&#125;)func floodFill(image [][]int, sr int, sc int, newColor int) [][]int &#123;    curColor := image[sr][sc]    if curColor != newColor &#123;        dfs(image, sr, sc, curColor, newColor)    &#125;    return image&#125;func dfs(image [][]int, rr, cc, curColor, newColor int) &#123;    if image[rr][cc] == curColor &#123;        image[rr][cc] = newColor        for i := 0; i &lt; 4; i++ &#123;            rrr, ccc := rr+r[i], cc+c[i]            if rrr &gt;= 0 &amp;&amp; rrr &lt; len(image) &amp;&amp; ccc &gt;= 0 &amp;&amp; ccc &lt; len(image[0]) &#123;                dfs(image, rrr, ccc, curColor, newColor)            &#125;        &#125;    &#125;&#125;</code></pre><p>执行用时：12 ms, 在所有 Go 提交中击败了5.22%的用户；</p><p>内存消耗：4.1 MB, 在所有 Go 提交中击败了75.54%的用户；</p><p>时间复杂度：O(m * n)，二维数组的每个位置（像素）都会被访问一次；</p><p>空间复杂度：O(m * n)，来自递归工作栈。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88.合并两个有序数组</title>
      <link href="/2021/11/30/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2021/11/30/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>由于本题需要将合并的结果存储在nums1中，为了防止nums1中原有的元素被覆盖掉，所以需要从后向前反向遍历，即使用两个指针p1和p2分别指向nums1的尾部和nums2的尾部，使用一个指针p指向下一个需要写入的单元。当p1和p2都没有越界时，将两个指针指向的内存单元中的较大者复制到p指向的内存单元中，并让p和对应的指针前进一步；当其中一个指针越界时，直接将另外一个指针指向的数组的内容拷贝到p所指向的内存单元中即可。</p><pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int) &#123;    p1, p2, p := m-1, n-1, m+n-1    for p1 &gt;= 0 || p2 &gt;= 0 &#123;        if p1 == -1 &#123;            // p1走到头            nums1[p] = nums2[p2]            p2--        &#125; else if p2 == -1 &#123;            // p2走到头            nums1[p] = nums1[p1]            p1--        &#125; else if nums1[p1] &gt; nums2[p2] &#123;            nums1[p] = nums1[p1]            p1--        &#125; else &#123;            nums1[p] = nums2[p2]            p2--        &#125;        p--    &#125;&#125;</code></pre><p>执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户；</p><p>内存消耗：2.3 MB, 在所有 Go 提交中击败了100.00%的用户；</p><p>时间复杂度：O(m+n)，需要遍历m、n两个数组各一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136.只出现一次的数字</title>
      <link href="/2021/11/30/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></p><h2 id="解法1：位运算（最优解）"><a href="#解法1：位运算（最优解）" class="headerlink" title="解法1：位运算（最优解）"></a>解法1：位运算（最优解）</h2><p>异或运算具有如下的性质：</p><ol><li>x ^ x == 0；</li><li>x ^ 0 == x。</li></ol><p>利用这条性质，我们可以将数组中的元素全部异或，由于异或运算的第一条性质，所有出现两次的数字都可以相互抵消，由于异或运算的第二条性质，最后剩下的那个没有被抵消的数字就是只出现一次的数字。</p><pre><code class="go">func singleNumber(nums []int) int &#123;    ans := 0    for _, v := range nums &#123;        ans ^= v    &#125;    return ans&#125;</code></pre><p>执行用时：16 ms, 在所有 Go 提交中击败了88.10%的用户</p><p>内存消耗：6.1 MB, 在所有 Go 提交中击败了99.96%的用户</p><p>时间复杂度：O(n)，需要遍历数组一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：哈希表（最简单）"><a href="#解法2：哈希表（最简单）" class="headerlink" title="解法2：哈希表（最简单）"></a>解法2：哈希表（最简单）</h2><p>如果想不到位运算的话，也可以用哈希表或者集合来完成这道题。用一个哈希表记录数字及其出现次数的关系，遍历数组，如果当前遍历到的数在哈希表中出现过，那么将其出现次数加1，否则将其放入哈希表中并置出现次数为1。最后遍历哈希表，找到出现次数为1的那个数返回即可。</p><pre><code class="go">func singleNumber(nums []int) int &#123;    // 哈希表    m := make(map[int]int)    for _, v := range nums &#123;        if _, ok := m[v]; ok &#123;            m[v]++        &#125; else &#123;            m[v] = 1        &#125;    &#125;    for k, v := range m &#123;        if v == 1 &#123;            return k        &#125;    &#125;    return -1&#125;</code></pre><p>执行用时：16 ms, 在所有 Go 提交中击败了88.37%的用户</p><p>内存消耗：6.9 MB, 在所有 Go 提交中击败了6.19%的用户</p><p>时间复杂度：O(n)，需要遍历数组一次，还需要遍历哈希表一次，由于哈希表的长度短于数组，所以整体时间复杂度为O(n)；</p><p>空间复杂度：O(n)，哈希表的长度与数组中元素的个数成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268.丢失的数字</title>
      <link href="/2021/11/30/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></p><h2 id="解法：位运算（异或）"><a href="#解法：位运算（异或）" class="headerlink" title="解法：位运算（异或）"></a>解法：位运算（异或）</h2><p>位运算中的异或具有有如下特性：</p><p>设x != y，那么x ^ x == 0，x ^ y != 0，x ^ 0 == x。</p><p>所以我们可以先把题目给定的数组都与0异或一遍，然后在将0~n与前一步得到的数异或一遍，这个过程中相同的数会相互抵消，最后剩下的数字就是没有在数组中出现的数字。</p><pre><code class="go">func missingNumber(nums []int) int &#123;    ans := 0    for _, v := range nums &#123;        ans ^= v    &#125;    for i := 0; i &lt;= len(nums); i++ &#123;        ans ^= i    &#125;    return ans&#125;</code></pre><p>执行用时：<strong>16</strong> ms, 在所有 Go 提交中击败了86.81%的用户</p><p>内存消耗：<strong>6.1</strong> MB, 在所有 Go 提交中击败了71.06%的用户</p><p>时间复杂度：O(n)，需要遍历数组一次，还需要遍历0~n一次，整体时间复杂度为O(n)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26.删除有序数组中的重复项</title>
      <link href="/2021/11/27/26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2021/11/27/26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>数组是有序的，这说明数组中重复的元素都是相邻的，所以可以使用双指针来删除这些重复的元素。首先让两个指针都指向数组的第二个元素（下标为1），然后使用快指针遍历数组，遇到两个相邻且不重复的元素则将第二个元素复制到慢指针指向的位置并让慢指针向前一步，否则（遇到两个相邻且重复的元素）就什么也不做，直接让快指针向前走一步，直到快指针走到数组末尾，此时慢指针指向的位置就是新数组的末尾，返回这个值即可。</p><p>例如，测试用例<code>[1, 1, 2]</code>中，第1个元素<code>1</code>和第2个元素<code>1</code>是相等的，所以不需要复制，快指针直接向前走一步，而第2个元素<code>1</code>和第三个元素<code>2</code>不相等，所以把第三个元素复制到第二个位置即可，此时数组为<code>[1, 2, 2]</code>并且快指针走到数组末尾、慢指针指向第2个元素，返回慢指针指向的位置的下标1即可。</p><pre><code class="go">func removeDuplicates(nums []int) int &#123;    if len(nums) == 0 &#123;        return 0    &#125;    s, f := 1, 1    for ; f &lt; len(nums); f++ &#123;        if nums[f] != nums[f-1] &#123;            nums[s] = nums[f]            s++        &#125;    &#125;    return s&#125;</code></pre><p>执行用时: <strong>8 ms</strong>（超过83.57%的Golang提交记录）</p><p>内存消耗: <strong>4.3 MB</strong>（超过99.97%的Golang提交记录）</p><p>时间复杂度：O(n)，需要遍历数组一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27.移动元素</title>
      <link href="/2021/11/27/27-%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2021/11/27/27-%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移动元素"><a href="#27-移动元素" class="headerlink" title="27. 移动元素"></a>27. 移动元素</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-element">27. 移动元素</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>由于题目要求原地移除所有符合要求的元素，所以可以使用快慢双指针来解决这个问题。开始之前两个指针都指向数组的第一个元素，然后使用快指针遍历整个数组，遇到与给定元素不相同的元素就复制到慢指针指向的位置，然后让慢指针向前走一步。循环结束时慢指针指向的数组下标就是删除完成后的数组长度，返回这个值即可。</p><pre><code class="go">func removeElement(nums []int, val int) int &#123;    if len(nums) == 0 &#123;        return 0    &#125;    s, f := 0, 0    for ; f &lt; len(nums); f++ &#123;        if nums[f] != val &#123;            nums[s] = nums[f]            s++        &#125;    &#125;    return s&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.1 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(n)，需要遍历数组一次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>700.二叉搜索树中的搜索</title>
      <link href="/2021/11/27/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2021/11/27/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p><h2 id="解法1：循环（效率更高）"><a href="#解法1：循环（效率更高）" class="headerlink" title="解法1：循环（效率更高）"></a>解法1：循环（效率更高）</h2><p>二叉搜索树（BST）的性质大家想必已经了解了：一个结点的所有左子节点都小于它本身，右子结点都大于它本身，那么按照这个方法一直搜索下去，直到搜索到要搜索的值或者搜索到空结点为止。</p><p>为了节省空间，我们可以用一个指针指向二叉搜索树的根结点，如果查找的目标值等于当前结点的值，则返回这个结点表示查找成功，如果目标值小于当前所指向的结点，就令指针指向它的左孩子，否则令指针指向它的右孩子，直到搜索到目标值或者指针走到空结点为止。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func searchBST(root *TreeNode, val int) *TreeNode &#123;    if root == nil &#123;        return nil    &#125;    p := root    for p != nil &#123;        if val == p.Val &#123;            return p        &#125; else if val &lt; p.Val &#123;            p = p.Left        &#125; else &#123; // val &gt; p.Val            p = p.Right        &#125;    &#125;    return nil&#125;</code></pre><p>执行用时: <strong>24 ms</strong>（超过61.94%的Golang提交记录）；</p><p>内存消耗: <strong>7.2 MB</strong>（超过40.53%的Golang提交记录）；</p><p>时间复杂度：O(n)，如果二叉搜索树是全都只有左/右子结点的单支树，那么当要查找的值不在树中时，二叉搜索树的每一个结点都需要被遍历一遍；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：递归（代码更简单）"><a href="#解法2：递归（代码更简单）" class="headerlink" title="解法2：递归（代码更简单）"></a>解法2：递归（代码更简单）</h2><p>虽然我在做这道题的时候第一反应就是循环，但是递归确实是一种对新手来说更友好的方法，它的代码更加简单，也更易懂。本题的递归条件如下：</p><ol><li>递归边界：空树，返回nil；</li><li>如果当前结点的值等于要查找的值，返回当前结点；</li><li>如果当前结点的值大于要查找的值，递归查找左子树；</li><li>如果当前结点的值小于要查找的值，递归查找右子树；</li></ol><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func searchBST(root *TreeNode, val int) *TreeNode &#123;    if root == nil &#123;        return nil    &#125;    if root.Val == val &#123;        return root    &#125; else if val &lt; root.Val &#123;        return searchBST(root.Left, val)    &#125; else &#123;        return searchBST(root.Right, val)    &#125;&#125;</code></pre><p>执行用时: <strong>24 ms</strong>（超过60.83%的Golang提交记录）；</p><p>内存消耗: <strong>7.2 MB</strong>（超过40.88%的Golang提交记录）；</p><p>时间复杂度：O(n)，如果二叉搜索树是全都只有左/右子结点的单支树，那么当要查找的值不在树中时，二叉搜索树的每一个结点都需要被遍历一遍；</p><p>空间复杂度：O(n)，来自递归工作栈，在上述最坏情况下栈的深度为树中结点个数。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104.二叉树的最大深度</title>
      <link href="/2021/11/23/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2021/11/23/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a></p><p>注意：<strong>本题是 559. N叉树的最大深度 的简化版。</strong></p><h2 id="解法1：深度优先搜索（DFS）"><a href="#解法1：深度优先搜索（DFS）" class="headerlink" title="解法1：深度优先搜索（DFS）"></a>解法1：深度优先搜索（DFS）</h2><p>对于这道题，最容易想到的解法就是递归DFS。递归条件如下：</p><ol><li>空树的最大深度为0；</li><li>叶子结点的最大深度为1（后来经测试，本条可以省略，不会出现问题）；</li><li>其他结点的最大深度 = max(左子树的最大深度，右子树的最大深度) + 1。</li></ol><pre><code class="go">func maxDepth(root *TreeNode) int &#123;    // 空树的深度为0    if root == nil &#123;        return 0    &#125;    // 叶子结点的深度为1    if root.Left == nil &amp;&amp; root.Right == nil &#123;        return 1    &#125;    // 其他结点的深度为其深度最大的子结点的深度+1    ans := 1    ld := maxDepth(root.Left)    rd := maxDepth(root.Right)    if ld &gt; ans &#123;        ans = ld    &#125;    if rd &gt; ans &#123;        ans = rd    &#125;    return ans + 1&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过88.65%的Golang提交记录）</p><p>内存消耗: <strong>4.2 MB</strong>（超过29.74%的Golang提交记录）</p><p>时间复杂度：O(n)，二叉树中的每个结点都会被遍历一次；</p><p>空间复杂度：O(d)，来自递归工作栈，其中d为二叉树的最大深度。</p><h2 id="解法2：广度优先搜索（BFS）"><a href="#解法2：广度优先搜索（BFS）" class="headerlink" title="解法2：广度优先搜索（BFS）"></a>解法2：广度优先搜索（BFS）</h2><p>这道题可以使用类似层序遍历的BFS算法求解，但是需要做一些改变：每次把队列缓存后清空队列，再遍历已缓存的队列，将其中的结点的子结点都加入到队列中并把答案加1，队列为空时就得到了二叉树的最大深度。</p><pre><code class="go">func maxDepth(root *TreeNode) int &#123;    // 空树的深度为0    if root == nil &#123;        return 0    &#125;    // BFS    queue := []*TreeNode&#123;root&#125;    depth := 0    for len(queue) &gt; 0 &#123;        tmp := queue        queue = []*TreeNode&#123;&#125;        // 遍历每一层的结点并将其子结点入队        for _, v := range tmp &#123;            if v.Left != nil &#123;                queue = append(queue, v.Left)            &#125;            if v.Right != nil &#123;                queue = append(queue, v.Right)            &#125;        &#125;        depth++    &#125;    return depth&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>4.2 MB</strong>（超过29.74%的Golang提交记录）</p><p>时间复杂度：O(n)，二叉树中的每个结点都会被遍历一次；</p><p>空间复杂度：O(n)，来自队列，在只有根结点的情况下队列的长度与树中结点个数一致。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>559.N叉树的最大深度</title>
      <link href="/2021/11/23/559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2021/11/23/559-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a>559. N叉树的最大深度</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree">559. N叉树的最大深度</a></p><h2 id="解法1：深度优先搜索（DFS）-递归"><a href="#解法1：深度优先搜索（DFS）-递归" class="headerlink" title="解法1：深度优先搜索（DFS）+递归"></a>解法1：深度优先搜索（DFS）+递归</h2><p>最容易想到的解法当然是递归+DFS，即对所有从根结点到某一叶子结点的路径进行遍历并求出路径长，所有路径中最长的就是我们要求的最大深度。</p><p>注意递归条件：</p><ol><li>空树的深度为0；</li><li>叶子结点的深度为1；</li><li>其余结点的深度为其子结点的深度+1。</li></ol><pre><code class="go">func maxDepth(root *Node) int &#123;    // 空树的深度为0    if root == nil &#123;        return 0    &#125;    // 叶子结点的深度为1    if root.Children == nil || len(root.Children) == 0 &#123;        return 1    &#125;    max := 1    for i := 0; i &lt; len(root.Children); i++ &#123;        cur := maxDepth(root.Children[i]) + 1        if cur &gt; max &#123;            max = cur        &#125;    &#125;    return max&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>3.2 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(n)，每个结点都需要被遍历一次；</p><p>空间复杂度：O(d)，来自递归工作栈，其中d为树的最大高度。</p><h2 id="解法2：广度优先搜索（BFS）"><a href="#解法2：广度优先搜索（BFS）" class="headerlink" title="解法2：广度优先搜索（BFS）"></a>解法2：广度优先搜索（BFS）</h2><p>另一种方法是类似于层序遍历的BFS算法。每次把本层的所有结点入队，暂存队列后清空队列，遍历被暂存的队列，将其子结点加入到队列中（这样可以保证每次队列中都只有某一层的结点）并将答案加1，队列为空时便得到了树的最大深度。</p><pre><code class="go">func maxDepth(root *Node) int &#123;    // 空树的深度为0    if root == nil &#123;        return 0    &#125;    ans := 0    queue := []*Node&#123;root&#125;    for len(queue) &gt; 0 &#123;        // 分层进行BFS        // 把队列暂存下来        tmp := queue        // 清空队列        queue = []*Node&#123;&#125;        // 把原队列中所有结点的子结点入队        for _, v := range tmp &#123;            queue = append(queue, v.Children...)        &#125;        // 层数+1        ans++    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>3.5 MB</strong>（超过10.04%的Golang提交记录）</p><p>时间复杂度：O(n)，每个结点都需要被遍历一次；</p><p>空间复杂度：O(n)，来自队列，在最坏情况下（多叉树的深度为2）队列长度最长，为n-1。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
            <tag> 多叉树 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>859.亲密字符串</title>
      <link href="/2021/11/23/859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/23/859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a>859. 亲密字符串</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/buddy-strings">859. 亲密字符串</a></p><h2 id="解法：模拟-哈希计数（使用数组表示）"><a href="#解法：模拟-哈希计数（使用数组表示）" class="headerlink" title="解法：模拟+哈希计数（使用数组表示）"></a>解法：模拟+哈希计数（使用数组表示）</h2><p>根据题意，如果两个字符串不满足以下条件，那么就绝对不是亲密字符串：</p><ol><li>长度相同；</li><li>词频相同；</li></ol><p>如果一个字符串满足以下两个条件之一，就是亲密字符串：</p><ol><li>所有位置上的字符都相同，但存在一个字符出现多于一次，可以将这两个相同的字符互换；</li><li>有两个位置上的字符不一样，其他位置上的字符均相同，可以将这两个不同的字符互换。</li></ol><p>由于go语言的数组使用<code>==</code>比较就是比较数组中的元素是否相同，所以可以使用一个长度为26的<code>int</code>类型数组模拟哈希表来记录两个字符串的词频，同时用<code>diff</code>记录两个字符串相同位置上字符不同的情况的出现次数，如果记录完成后两个数组不相等，那么不满足“词频相同这一条件”，返回<code>false</code>，然后遍历原字符串对应的数组，如果找到某个字符的出现次数大于1并且<code>diff</code>为0，那么满足条件2；如果<code>diff</code>为2，那么满足条件1，只有这两种情况返回<code>true</code>，其他情况均返回<code>false</code>。</p><pre><code class="go">func buddyStrings(s string, goal string) bool &#123;    if len(s) != len(goal) &#123;        return false    &#125;    a, b := [26]int&#123;&#125;, [26]int&#123;&#125;    diff := 0    for i := 0; i &lt; len(s); i++ &#123;        if s[i] != goal[i] &#123;            diff++        &#125;        a[s[i]-&#39;a&#39;]++        b[goal[i]-&#39;a&#39;]++    &#125;    if a != b &#123;        return false    &#125;    ok := false    for _, v := range a &#123;        if v &gt; 1 &#123;            ok = true        &#125;    &#125;    return diff == 2 || (diff == 0 &amp;&amp; ok)&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.4 MB</strong>（超过58.57%的Golang提交记录）</p><p>时间复杂度：O(n)，对于长度为<code>n</code>的字符串需要遍历一次，还需要遍历一次长度固定为26的数组，所以时间复杂度为O(n)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间，注意本题虽然使用了两个长度为26的数组，但是这个值固定为26，不随问题规模而变化。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现堆排序</title>
      <link href="/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang实现堆排序"><a href="#Golang实现堆排序" class="headerlink" title="Golang实现堆排序"></a>Golang实现堆排序</h1><h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>堆是一种将数据以<strong>完全二叉树</strong>的顺序存储在<strong>一维数组</strong>中的结构。</p><p>堆分为两种：大顶堆和小顶堆。</p><ul><li>大顶堆/大根堆：任意结点的值均<strong>大于等于</strong>其左右孩子，且<strong>最大</strong>的元素位于堆顶（根结点）；</li><li>小顶堆/小根堆：任意结点的值均<strong>小于等于</strong>其左右孩子，且<strong>最小</strong>的元素位于堆顶（根结点）。</li></ul><h2 id="Go语言实现堆排序"><a href="#Go语言实现堆排序" class="headerlink" title="Go语言实现堆排序"></a>Go语言实现堆排序</h2><p>堆排序的过程：</p><ol><li>建初始大顶堆：将数组中的元素构建成完全二叉树，从最后一个父结点开始往前遍历，构造出初始大顶堆，当交换了<code>nums[0]</code>和<code>nums[1]</code>之后构建结束，此时根结点就是数组中最大的元素；</li><li>调整：移除根结点，用数组的最后一个元素代替，将堆重新调整为大顶堆：如果一个结点的值小于其左孩子或者右孩子，就将两个结点交换，然后继续调整被交换的结点的子结点（也就是原结点的孙结点），直到下标越界或父结点的值大于其左右孩子的值时调整完毕，跳出循环；</li><li>根据以上操作每次都可以拿到一个最大的元素，直到数组全部遍历完成，此时数组就是按升序排序的了。</li></ol><p>注：如果是要按降序排序则需要使用小顶堆。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    nums := []int&#123;9, 8, 2, 3, 4, 1, 2, 0, 5, 8, 7, 5, 6&#125;    heapSort(nums)    fmt.Println(nums)&#125;func heapSort(nums []int) &#123;    // 特殊情况:数组长度为0或者1,此时不需要排序,直接返回    if nums == nil || len(nums) &lt; 2 &#123;        return    &#125;    n := len(nums)    // 构造初始大顶堆:从最后一个父结点(n / 2 - 1)开始从后往前调整，直到交换了nums[0]和nums[1]为止    // 堆是一个用数组表示的完全二叉树,其每个结点都不大于/不小于左右孩子的值    // 当前结点:nums[i],左孩子:nums[i * 2 + 1],右孩子nums[i * 2 + 2]    // 父结点:nums[i / 2 - 1]    for i := n / 2 - 1; i &gt;= 0; i-- &#123;        heapAdjust(nums, i)    &#125;    for i := n; i &gt; 1; i-- &#123;        // 初始大顶堆建好之后把根结点(最大值)拿出来,并把最后一个元素放到原来根结点的位置上        // 再把剩下的元素构造成新的大顶堆,并再次取出根结点        // 直到数组排序完成        nums[0], nums[i-1] = nums[i-1], nums[0]        heapAdjust(nums[:i-1], 0)    &#125;&#125;func heapAdjust(nums []int, index int) &#123;    i := index    // 当结点的值在数组中时才进行调整,否则直接返回    for i &lt; len(nums) &#123;        child := 0        left, right := 2 * i + 1, 2 * i + 2        if right &lt; len(nums) &#123;            // 左右孩子都存在,选出较大的子结点            if nums[left] &gt; nums[right] &#123;                child = left            &#125; else &#123;                child = right            &#125;        &#125; else if left &lt; len(nums) &#123;            // 存在左孩子但不存在右孩子,则选出左孩子            child = left        &#125;        if child &gt; 0 &amp;&amp; nums[child] &gt; nums[i] &#123;            // 对堆进行调整,交换父子结点的值,把更大的值换到父结点上去            nums[i], nums[child] = nums[child], nums[i]            // 下一轮循环再比较孙结点            i = child        &#125; else &#123;            // 父结点大于子结点的值,满足大顶堆的定义,跳出循环            break        &#125;    &#125;&#125;</code></pre><h2 id="堆排序的性质"><a href="#堆排序的性质" class="headerlink" title="堆排序的性质"></a>堆排序的性质</h2><ul><li>时间复杂度：<code>O(nlogn)</code>（最好、最坏、平均都是该值）；</li><li>空间复杂度：<code>O(1)</code>；</li><li>稳定性：不稳定，因为每次调整走的是被调整结点到叶子结点的一条路径，可能会出现排在后面的元素被交换到前面的情况。</li></ul><h2 id="拓展：Top-K问题"><a href="#拓展：Top-K问题" class="headerlink" title="拓展：Top K问题"></a>拓展：Top K问题</h2><p>Top K问题：在一堆数据里面找到前K大/小的元素。</p><h3 id="解法1：排序"><a href="#解法1：排序" class="headerlink" title="解法1：排序"></a>解法1：排序</h3><p>可以使用<code>O(nlogn)</code>的时间复杂度的排序算法对数据进行排序。这种方法在数据量比较小的时候可行，但数据量很大的时候不是最优解。</p><h3 id="解法2：快速排序"><a href="#解法2：快速排序" class="headerlink" title="解法2：快速排序"></a>解法2：快速排序</h3><p>快速排序的划分（<code>partation</code>）思想可以用于计算中位数等问题。每次经过划分，如果基准的下标等于<code>K</code>，那么其左/右边的数就是Top K；如果不等于，则递归处理左/右边的数据。</p><p>时间复杂度：O(n)</p><p>缺点：在内存有限的情况下因为无法将所有元素一次性读到内存中，因而不适用于海量数据。</p><h3 id="解法3：堆排序"><a href="#解法3：堆排序" class="headerlink" title="解法3：堆排序"></a>解法3：堆排序</h3><p>堆排序是Top K问题最经典的解法。</p><p>以找最大的K个元素为例：维护一个大小为Top K的小顶堆，首先取K个元素构建初始堆，接着把每一个元素跟堆顶元素比较：如果大于堆顶元素则去除当前的堆顶元素并将新元素插入堆中，如果小于堆顶元素则直接扔掉该元素。遍历结束之后堆中的数据就是我们要求的Top K。</p><p>如果要求的是最小的K个元素则使用大顶堆即可。</p><p>时间复杂度：遍历数组为O(n)，建堆操作为O(logK)，综合下来时间复杂度为O(nlogK)。</p><p>注：如果语言支持的话（如Java、C++等），堆可以使用优先队列来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现快速排序</title>
      <link href="/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang实现快速排序"><a href="#Golang实现快速排序" class="headerlink" title="Golang实现快速排序"></a>Golang实现快速排序</h1><h2 id="快速排序的思想"><a href="#快速排序的思想" class="headerlink" title="快速排序的思想"></a>快速排序的思想</h2><p>快速排序的核心思想是划分，即选定一个基准，将数组划分为两部分：基准左边的部分都小于它，而右边的部分都大于它。</p><p>详细步骤如下：</p><ol><li>选定一个基准，比如数组中的第一个数；</li><li>使用两个指针<code>low</code>和<code>high</code>指向数组的第一个位置和最后一个位置，当<code>nums[high]</code>大于基准时让<code>high</code>向左走，当<code>nums[low]</code>小于基准且<code>low &lt; high</code>时让<code>low</code>向右走，跳出循环时<code>low</code>指向的是从左向右数第一个大于基准的数，而<code>high</code>指向了从右向左数第一个小于基准的数，将这两个数交换；</li><li>当<code>low</code>和<code>high</code>相遇时退出循环，将基准与该数进行交换；</li><li>递归地对基准的左右两侧进行排序，直到数组全部排完。</li></ol><h2 id="Go语言实现快速排序"><a href="#Go语言实现快速排序" class="headerlink" title="Go语言实现快速排序"></a>Go语言实现快速排序</h2><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    nums := []int&#123;4, 5, 7, 1, 2, 9, 0, 8, 3, 1, 6, 2, 1, 0&#125;    quickSort(nums, 0, len(nums)-1)    fmt.Println(nums)&#125;func quickSort(nums []int, start, end int) &#123;    if start &lt; end &#123;        pivot := partition(nums, start, end)        quickSort(nums, start, pivot-1)        quickSort(nums, pivot+1, end)    &#125;&#125;func partition(nums []int, start, end int) int &#123;    low, high := start, end    // 以数组的第一个元素作为基准    pivot := nums[low]    for low &lt; high &#123;        // 找到第一个小于基准的元素        // 因为基准选的是数组的第一个元素,所以这里不会越界        for nums[high] &gt; pivot &#123;            high--        &#125;        // 找到第一个大于基准的元素        // 这里可能会越界,所以需要判断一下        for nums[low] &lt;= pivot &amp;&amp; low &lt; high &#123;            low++        &#125;        if low &gt;= high &#123;            break        &#125;        // 交换两个元素        nums[low], nums[high] = nums[high], nums[low]    &#125;    // 跳出循环的时候两个指针指向了同一个位置,把基准填到该位置    nums[start], nums[low] = nums[low], nums[start]    // 返回基准的位置    return low&#125;</code></pre><h2 id="快速排序的性质"><a href="#快速排序的性质" class="headerlink" title="快速排序的性质"></a>快速排序的性质</h2><ul><li>时间复杂度：<code>O(nlogn)</code>（平均、最好），<code>O(n^2)</code>最坏；</li><li>空间复杂度：<code>O(logn)</code>，来自递归调用栈；</li><li>稳定性：不稳定，比如<code>3, 7, 7, 1, 1</code>这个序列的第二个1就会被换到第一个1前面去。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现希尔排序</title>
      <link href="/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang实现希尔排序"><a href="#Golang实现希尔排序" class="headerlink" title="Golang实现希尔排序"></a>Golang实现希尔排序</h1><h2 id="希尔排序的思想"><a href="#希尔排序的思想" class="headerlink" title="希尔排序的思想"></a>希尔排序的思想</h2><p>希尔排序属于插入类排序，是将整个序列分成几个较小的子序列分别进行插入排序。</p><p>首先取一个增量（例如2），然后使用数组长/增量计算得到步长，间隔相同步长的所有元素被视为一组，接着对每组的元素分别进行直接插入排序，然后逐渐缩小增量，直到增量为1时整个数组有序，算法结束。</p><h2 id="Go语言实现希尔排序"><a href="#Go语言实现希尔排序" class="headerlink" title="Go语言实现希尔排序"></a>Go语言实现希尔排序</h2><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    nums := []int&#123;4, 5, 7, 1, 2, 9, 0, 8, 3, 1, 6, 2, 1, 0&#125;    shellSort(nums)    fmt.Println(nums)&#125;func shellSort(nums []int) &#123;    n := len(nums)    // 增量,选择合适的增量有助于提高性能    inc := 2    // 步长 = 数组长 / 增量    step := n / inc    for ; step &gt; 0; step /= inc &#123;        for i := step; i &lt; n; i++ &#123;            // 从第i个元素开始,逐个对其所在的组进行直接插入排序            l := i - step            insertValue := nums[i]            for ; l &gt;= 0 &amp;&amp; insertValue &lt; nums[l]; l -= step &#123;                nums[l+step] = nums[l]            &#125;            nums[l+step] = insertValue        &#125;    &#125;&#125;</code></pre><h2 id="希尔排序的性质"><a href="#希尔排序的性质" class="headerlink" title="希尔排序的性质"></a>希尔排序的性质</h2><ul><li>时间复杂度：未知，与增量的选择有关，一般为<code>O(n^1.3) ~ O(n^2)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：不稳定，虽然针对每一组的直接插入排序是稳定的，但是不同组之间的分组插入排序是不稳定的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现前缀树Trie</title>
      <link href="/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91Trie/"/>
      <url>/2021/11/22/Golang%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91Trie/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang实现前缀树Trie"><a href="#Golang实现前缀树Trie" class="headerlink" title="Golang实现前缀树Trie"></a>Golang实现前缀树Trie</h1><h2 id="什么是前缀树"><a href="#什么是前缀树" class="headerlink" title="什么是前缀树"></a>什么是前缀树</h2><p>前缀树，又称Trie、字典树、单词查找树或键树，是多叉树的一种特殊形式。前缀树中的每一个结点都代表一个字符，根结点代表空字符串，其子结点保存的字符串是由通往该子结点路径上的所有字符组成的，并且每个子结点包含的字符都不相同。</p><p>前缀树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="结点的实现"><a href="#结点的实现" class="headerlink" title="结点的实现"></a>结点的实现</h3><p>我们先只考虑存储26个小写英文字母的前缀树，这是一棵26叉树，可以用一个长度为26的数组保存其所有子结点。由于我们走到某个结点的时候需要知道是不是已经达到该单词的末尾了（例如前缀树里有字符串<code>goroutines</code>但没有<code>goroutine</code>，读到<code>e</code>的时候显然就没有读到单词末尾，而读到<code>s</code>的时候则达到了单词尾），所以每个结点都需要附带一个<code>isWord</code>字段来标识是否已经达到单词尾。</p><pre><code class="go">// Trie 前缀树结点type Trie struct &#123;    isWord   bool      // 判断一个结点是不是走到单词尾    children [26]*Trie // 子结点,长度为26的数组&#125;</code></pre><p>注意：如果要实现存储任意字符的前缀树，可以把<code>children</code>数组替换为<code>map[rune]*Trie</code>。</p><h3 id="插入方法的实现"><a href="#插入方法的实现" class="headerlink" title="插入方法的实现"></a>插入方法的实现</h3><p>再来看看如何向前缀树中插入一个单词。我们使用一个指针指向前缀树的根结点，然后遍历单词中的每一个字符，对于当前遍历到的字符求出其相对于字母<code>a</code>的偏移量（也就是这个字符在<code>children</code>数组中的位置），然后查看数组对应位置上的值是不是<code>nil</code>。如果是，则在这个位置上新建一个结点，并把指针移动到新建的结点上；如果不是，则直接把指针移动到这个已存在的子结点上。读到单词尾后，将指针指向的结点的<code>isWord</code>字段置为<code>true</code>，表示读到该位置之后单词已经结束。</p><p>代码如下：</p><pre><code class="go">// Insert 向前缀树中插入一个单词func (root *Trie) Insert(word string) &#123;    cur := root    for i, c := range word &#123;        // 计算出当前位置上字符的偏移量        loc := c - &#39;a&#39;        // 如果这个位置上没有子结点,就新建一个        if cur.children[loc] == nil &#123;            cur.children[loc] = &amp;Trie&#123;&#125;        &#125;        // 把指针移动到被插入的结点上        cur = cur.children[loc]        // 如果读到单词尾,那么把这个结点设为单词结尾        if i == len(word)-1 &#123;            cur.isWord = true        &#125;    &#125;&#125;</code></pre><p>注意：如果使用<code>map</code>而不是数组，判断子结点是否存在的时候可以使用<code>_, ok := children[c]; !ok</code>（其中<code>c</code>为当前遍历到的字符）。</p><h3 id="查找方法的实现"><a href="#查找方法的实现" class="headerlink" title="查找方法的实现"></a>查找方法的实现</h3><p>查找和插入是比较相似的，仍然是一个指针遍历的过程，区别在于如果遍历到某个结点时发现当前结点的子结点中不存在字符串当前位置上的字符，则直接返回<code>false</code>表示查找失败，并且遍历完成之后还要判断最后遍历到的结点的<code>isWord</code>字段是不是<code>true</code>。</p><pre><code class="go">// Search 查找一个前缀树里有没有某个单词func (root *Trie) Search(word string) bool &#123;    cur := root    for _, c := range word &#123;        loc := c - &#39;a&#39;        // 如果当前位置对应的子结点里没有要查找的结点,那说明这个单词不在前缀树里        if cur.children[loc] == nil &#123;            return false        &#125;        // 如果有,则把指针移动到这个结点上        cur = cur.children[loc]    &#125;    // 遍历结束之后判断一下是否读到单词尾,如果是,则返回true    // 如果没有读到单词尾,那说明这个单词还没有结束，要查找的单词没有被插入前缀树    return cur.isWord&#125;</code></pre><h3 id="判断前缀方法的实现"><a href="#判断前缀方法的实现" class="headerlink" title="判断前缀方法的实现"></a>判断前缀方法的实现</h3><p>判断前缀和查找比较相似，但由于不需要判断是否读到单词尾，所以只需要把最后的判断条件去掉而是直接返回<code>true</code>。</p><pre><code class="go">// StartWith 查找某个前缀是否存在于前缀树中func (root *Trie) StartWith(prefix string) bool &#123;    cur := root    for _, c := range prefix &#123;        loc := c - &#39;a&#39;        // 当前位置对应的子结点里没有要查找的结点,说明这个前缀不在前缀树里        if cur.children[loc] == nil &#123;            return false        &#125;        cur = cur.children[loc]    &#125;    return true&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="go">package trie// Trie 前缀树结点type Trie struct &#123;    isWord   bool      // 判断一个结点是不是走到单词尾    children [26]*Trie // 子结点,长度为26的数组&#125;// NewTrie 新建一个前缀树func NewTrie() *Trie &#123;    return &amp;Trie&#123;&#125;&#125;// Insert 向前缀树中插入一个单词func (root *Trie) Insert(word string) &#123;    cur := root    for i, c := range word &#123;        // 计算出当前位置上字符的偏移量        loc := c - &#39;a&#39;        // 如果这个位置上没有子结点,就新建一个        if cur.children[loc] == nil &#123;            cur.children[loc] = &amp;Trie&#123;&#125;        &#125;        // 把指针移动到被插入的结点上        cur = cur.children[loc]        // 如果读到单词尾,那么把这个结点设为单词结尾        if i == len(word)-1 &#123;            cur.isWord = true        &#125;    &#125;&#125;// Search 查找一个前缀树里有没有某个单词func (root *Trie) Search(word string) bool &#123;    cur := root    for _, c := range word &#123;        loc := c - &#39;a&#39;        // 如果当前位置对应的子结点里没有要查找的结点,那说明这个单词不在前缀树里        if cur.children[loc] == nil &#123;            return false        &#125;        // 如果有,则把指针移动到这个结点上        cur = cur.children[loc]    &#125;    // 遍历结束之后判断一下是否读到单词尾,如果是,则返回true    // 如果没有读到单词尾,那说明这个单词还没有结束，要查找的单词没有被插入前缀树    return cur.isWord&#125;// StartWith 查找某个前缀是否存在于前缀树中func (root *Trie) StartWith(prefix string) bool &#123;    cur := root    for _, c := range prefix &#123;        loc := c - &#39;a&#39;        // 当前位置对应的子结点里没有要查找的结点,说明这个前缀不在前缀树里        if cur.children[loc] == nil &#123;            return false        &#125;        cur = cur.children[loc]    &#125;    return true&#125;</code></pre><p>测试代码：</p><pre><code class="go">package trieimport (    &quot;fmt&quot;    &quot;testing&quot;)func TestTrie(t *testing.T) &#123;    trie := NewTrie()    trie.Insert(&quot;golang&quot;)    trie.Insert(&quot;goroutines&quot;)    fmt.Println(trie.StartWith(&quot;go&quot;))      // true    fmt.Println(trie.Search(&quot;goroutine&quot;))  // false    fmt.Println(trie.Search(&quot;golang&quot;))     // true    fmt.Println(trie.Search(&quot;goroutines&quot;)) // true&#125;</code></pre><p>测试结果：</p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20211116211006.png" style="zoom:50%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/idwtwt/article/details/88193548">前缀树Trie及代码实现（golang）</a></li><li><a href="https://blog.csdn.net/terrygmx/article/details/88921823">Golang实现Trie（前缀树）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Trie </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1436.旅行终点站</title>
      <link href="/2021/11/22/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/"/>
      <url>/2021/11/22/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="1436-旅行终点站"><a href="#1436-旅行终点站" class="headerlink" title="1436. 旅行终点站"></a>1436. 旅行终点站</h1><p>题目地址👉 <a href="https://leetcode-cn.com/problems/destination-city/">1436. 旅行终点站</a></p><h2 id="解法1：结点-出度表（想复杂了）"><a href="#解法1：结点-出度表（想复杂了）" class="headerlink" title="解法1：结点-出度表（想复杂了）"></a>解法1：结点-出度表（想复杂了）</h2><p>看到这题第一反应是图，题目中要求的又是出度为0的结点，那么自然而然地就想到了求所有结点的出度并保存在<code>map</code>中，最后遍历<code>map</code>并返回出度为0的结点的方法。</p><p>详细解法请看注释👇</p><pre><code class="go">func destCity(paths [][]string) string &#123;  // path数组的第一个参数为起点,第二个参数为终点    // 那么我们就可以建立一个map,key为城市(结点),value为从该城市出发的线路条数(出度)    // 遍历二维数组中的每一条路线    // 若起点不在map中,则把起点放入map并置出度为1    // 若终点不在map中,则把终点放入map并置出度为0    // 若起点在map中,则把对应起点的出度加1    // 若终点在map中,则不做任何处理    // 最后返回出度为0的结点名称即可    if len(paths) == 0 &#123;        return &quot;&quot;    &#125;    g := make(map[string]int, 0)    for _, city := range paths &#123;        if _, ok := g[city[0]]; !ok &#123;            // 若起点不在map中,则把起点放入map并置出度为1            g[city[0]] = 1        &#125; else &#123;            // 若起点在map中,则把对应起点的出度加1            g[city[0]] += 1        &#125;        // 若终点不在map中,则把终点放入map并置出度为0        if _, ok := g[city[1]]; !ok &#123;            g[city[1]] = 0        &#125;    &#125;    for k, v := range g &#123;        // 最后返回出度为0的结点名称即可        if v == 0 &#123;            return k        &#125;    &#125;    return &quot;&quot;&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过85%的Golang提交记录）</p><p>内存消耗: <strong>4 MB</strong>（超过31%的Golang提交记录）</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h2 id="解法2：哈希表的正确使用方法（官方解法）"><a href="#解法2：哈希表的正确使用方法（官方解法）" class="headerlink" title="解法2：哈希表的正确使用方法（官方解法）"></a>解法2：哈希表的正确使用方法（官方解法）</h2><p>我本来以为我想到的解法是一个比较正常的解法，但是看了官方题解之后我发现我想的实在是太复杂了，果然感冒的时候就应该好好休息不要刷题。。。</p><p>官方解法的思路其实很简单：因为一条线路的起点站是<code>path[0]</code>，终点站是<code>path[1]</code>，所以在<code>path[1]</code>中出现而没有在<code>path[0]</code>中出现的结点就是我们要求的终点站了。</p><pre><code class="go">func destCity(paths [][]string) string &#123;  // 官方解法,建哈希表,比我自己想的要简单    if len(paths) == 0 &#123;        return &quot;&quot;    &#125;    s := make(map[string]bool, 0)    for _, route := range paths &#123;        s[route[0]] = true    &#125;    for _, route := range paths &#123;        if _, ok := s[route[1]]; !ok &#123;            return route[1]        &#125;    &#125;    return &quot;&quot;&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过85%的Golang提交记录）</p><p>内存消耗: <strong>3.9 MB</strong>（超过64%的Golang提交记录）</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1137.第N个泰波那契数</title>
      <link href="/2021/11/22/1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
      <url>/2021/11/22/1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1137-第N个泰波那契数"><a href="#1137-第N个泰波那契数" class="headerlink" title="1137. 第N个泰波那契数"></a>1137. 第N个泰波那契数</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第N个泰波那契数</a></p><h2 id="解法：记忆化搜索（动态规划-状态压缩）"><a href="#解法：记忆化搜索（动态规划-状态压缩）" class="headerlink" title="解法：记忆化搜索（动态规划+状态压缩）"></a>解法：记忆化搜索（动态规划+状态压缩）</h2><p>动态规划入门题，其实就是509多算了一位而已，代码基本上跟509没有区别。</p><pre><code class="go">func tribonacci(n int) int &#123;    if n == 0 &#123;        return 0    &#125;    if n == 1 &#123;        return 1    &#125;    if n == 2 &#123;        return 1    &#125;    pre1, pre, cur := 0, 1, 1    for i := 3; i &lt;= n; i++ &#123;        j := pre1 + pre + cur        pre1 = pre        pre = cur        cur = j    &#125;    return cur&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过31.87%的Golang提交记录）</p><p>时间复杂度：O(n)，除了求0、1、2之外都需要遍历<code>n - 2</code>次才能计算出答案；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977.有序数组的平方</title>
      <link href="/2021/11/22/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2021/11/22/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>最容易想到的解法当然是把每一个数都平方后再进行排序，但是那种方法太低效了。</p><p>我们可以找到时间复杂度为O(n)而且还很好理解的解法：双指针，具体步骤如下：</p><ol><li>创建一个与原数组等大的数组<code>ans</code>用于存放答案，并创建一个整数<code>pos</code>存放<code>len(nums)-1</code>；</li><li>使用两个整数<code>i</code>，<code>j</code>分别保存<code>0</code>和<code>len(nums)-1</code>；</li><li>循环，每次比较<code>nums[i]</code>与<code>nums[j]</code>平方的大小，若<code>nums[i]</code>的平方较大则将其放入<code>ans[pos]</code>并将<code>i</code>加1，若<code>nums[j]</code>的平方较大则将其放入<code>ans[pos]</code>并将<code>j</code>减1，每次循环将<code>pos</code>减1，直到<code>pos</code>小于0，即<code>ans</code>数组全部填满。</li></ol><pre><code class="go">func sortedSquares(nums []int) []int &#123;    ans := make([]int, len(nums))    i, j := 0, len(nums) - 1    for pos := len(nums) - 1; pos &gt;= 0; pos-- &#123;        k, l := nums[i], nums[j]        k *= k        l *= l        if k &gt; l &#123;            ans[pos] = k            i++        &#125; else &#123;            ans[pos] = l            j--        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>28 ms</strong>（超过78.80%的Golang提交记录）</p><p>内存消耗: <strong>6.8 MB</strong>（超过22.11%的Golang提交记录）</p><p>时间复杂度：O(n)，对于长度为<code>n</code>的数组需要遍历<code>n</code>次；</p><p>空间复杂度：O(1)，除了返回值之外只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746.使用最小花费爬楼梯</title>
      <link href="/2021/11/22/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2021/11/22/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p><h2 id="解法：动态规划-状态压缩"><a href="#解法：动态规划-状态压缩" class="headerlink" title="解法：动态规划+状态压缩"></a>解法：动态规划+状态压缩</h2><p>题目描述的不明不白的，但是看出来是要用动态规划。看了题解才明白这题要干啥，也明白了解题思路：</p><p>其实思路很简单：踏上第<code>i</code>级台阶有两种方法：</p><ol><li>先踏上第<code>i - 1</code>级台阶，再一次爬一级踏上第<code>i</code>级台阶；</li><li>先踏上第<code>i - 2</code>级台阶，再一次爬两级踏上第<code>i</code>级台阶。</li></ol><p>题目要找的是最小花费，那么只需要找出这两个里面值里面最小的，即<code>min(cost[i-1], cost[i-2]) + cost[i]</code>，就是踏上第<code>i</code>级台阶的最小花费。明白了这一点之后我们发现这道题其实跟509的基本思路一样，用两个变量<code>pre</code>和<code>cur</code>记录<code>cost[i-2]</code>和<code>cost[i-1]</code>，然后迭代算下去即可。</p><p>注意：因为踏上最后一级台阶后不需要再花费体力，所以最后只需要返回<code>pre</code>和<code>cur</code>中较小者即可。</p><pre><code class="go">func minCostClimbingStairs(cost []int) int &#123;    pre, cur := cost[0], cost[1]    for i := 2; i &lt; len(cost); i++ &#123;        j := min(pre, cur) + cost[i]        pre = cur        cur = j    &#125;    return min(pre, cur)&#125;func min(a, b int) int &#123;    if a &lt; b &#123;        return a    &#125;    return b&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过83.45%的Golang提交记录）</p><p>内存消耗: <strong>2.8 MB</strong>（超过85.21%的Golang提交记录）</p><p>时间复杂度：O(n)，<code>for</code>循环需要执行<code>len(cost)</code>次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704.二分查找</title>
      <link href="/2021/11/22/704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/11/22/704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/binary-search">704. 二分查找</a></p><h2 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h2><p>二分查找的代码大家应该都背的滚瓜烂熟了吧，这里就着重讲一下二分查找的一些小技巧：</p><ol><li>在使用<code>mid = (left + right) / 2</code>可能发生溢出的情况下，可以套用<code>mid = left + (right - left) / 2</code>的公式避免溢出；</li><li>除以2这个操作可以用右移1位来代替，会更快一些：<code>mid = left + (right - left) &gt;&gt; 1</code></li></ol><pre><code class="go">func search(nums []int, target int) int &#123;    l, r := 0, len(nums)-1    for l &lt;= r &#123;        mid := l + (r-l)&gt;&gt;1        if nums[mid] == target &#123;            return mid        &#125; else if nums[mid] &lt; target &#123;            l = mid + 1        &#125; else &#123;            r = mid - 1        &#125;    &#125;    return -1&#125;</code></pre><p>执行用时: <strong>32 ms</strong>（超过80.69%的Golang提交记录）</p><p>内存消耗: <strong>6.7 MB</strong>（超过25.59%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>658.找到K个最接近的元素</title>
      <link href="/2021/11/22/658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2021/11/22/658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="658-找到-K-个最接近的元素"><a href="#658-找到-K-个最接近的元素" class="headerlink" title="658. 找到 K 个最接近的元素"></a>658. 找到 K 个最接近的元素</h1><p>题目地址👉<a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></p><h2 id="解法1：删除法（双指针）"><a href="#解法1：删除法（双指针）" class="headerlink" title="解法1：删除法（双指针）"></a>解法1：删除法（双指针）</h2><p>从数组的两端不断删除与x的差值更大的元素直到数组长度为k，看到这题第一个想到的就是这个方法，也是一个比较简单的方法，可惜的是在n很大k很小的时候效率不高。</p><p>注意：因为若<code>x</code>在数组中那么<code>x</code>比<code>arr[0]</code>大而比<code>arr[len(arr)-1]</code>小，所以如果不想调用<code>math.Abs()</code>或者自己写绝对值函数取绝对值的话判断条件就需要写成<code>x-arr[0] &gt; arr[len(arr)-1]-x</code>。<code>x</code>不在数组中的情况也是类似的考虑方法。</p><pre><code class="go">func findClosestElements(arr []int, k int, x int) []int &#123;    for len(arr) &gt; k &#123;        if x-arr[0] &gt; arr[len(arr)-1]-x &#123;            arr = arr[1:]        &#125; else &#123;            arr = arr[:len(arr)-1]        &#125;    &#125;    return arr&#125;</code></pre><p>执行用时: <strong>32 ms</strong>（超过97%的Golang提交记录）</p><p>内存消耗: <strong>6.9 MB</strong>（超过39%的Golang提交记录）</p><p>时间复杂度：O(n - k)</p><p>空间复杂度：O(1)</p><h2 id="解法2：二分查找"><a href="#解法2：二分查找" class="headerlink" title="解法2：二分查找"></a>解法2：二分查找</h2><p>标准的二分查找代码，只不过判断条件改成了判断<code>x-arr[mid]</code>和<code>arr[mid+k]-x</code>的大小关系而不是判断<code>x</code>与<code>arr[mid]</code>是否相等，并且因为要返回<code>k</code>个元素所以起始条件中的右边界<code>s</code>为<code>len(arr)-k</code>而不是<code>len(arr)</code>。</p><p>这种方法不如删除法好想到，但是最坏时间复杂度更优秀一些。</p><pre><code class="go">func findClosestElements(arr []int, k int, x int) []int &#123;  s, g := len(arr)-k, 0    for g &lt; s &#123;        mid := (s + g) / 2        if x-arr[mid] &gt; arr[mid+k]-x &#123;            g = mid + 1        &#125; else &#123;            s = mid        &#125;    &#125;    return arr[g : g+k]&#125;</code></pre><p>执行用时: <strong>36 ms</strong>（超过85%的Golang提交记录）</p><p>内存消耗: <strong>6.9 MB</strong>（超过62%的Golang提交记录）</p><p>时间复杂度：O(logn + k)</p><p>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>594.最长和谐子序列</title>
      <link href="/2021/11/22/594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2021/11/22/594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a>594. 最长和谐子序列</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence">594. 最长和谐子序列</a></p><h2 id="解法一：哈希表（空间换时间，最容易想到）"><a href="#解法一：哈希表（空间换时间，最容易想到）" class="headerlink" title="解法一：哈希表（空间换时间，最容易想到）"></a>解法一：哈希表（空间换时间，最容易想到）</h2><p>看到这道题的时候本能的反应就是哈希表。具体来说是遍历数组时将数组中的每个元素及其出现次数记录到哈希表中，然后再次遍历数组，判断该数减1的数是否在哈希表中，如果在，那么将它们的出现次数相加就能得到一个和谐子序列的长度，再将其与答案比较（答案初始化为1），如果该和谐子序列的长度比答案更长，就将答案更新为该长度。</p><pre><code class="go">func findLHS(nums []int) int &#123;    m := make(map[int]int)    for _, n := range nums &#123;        if _, ok := m[n]; !ok &#123;            m[n] = 1        &#125; else &#123;            m[n] += 1        &#125;    &#125;    ans := 0    for _, n := range nums &#123;        if _, ok := m[n-1]; ok &#123;            if m[n]+m[n-1] &gt; ans &#123;                ans = m[n] + m[n-1]            &#125;        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>56 ms</strong>（超过54.82%的Golang提交记录）</p><p>内存消耗: <strong>7.2 MB</strong>（超过28.51%的Golang提交记录）</p><p>时间复杂度：O(n)，在整个过程中需要遍历两次数组；</p><p>空间复杂度：O(n)，最坏情况下数组中所有元素都不相同，此时哈希表的长度为数组长度。</p><h2 id="解法二：排序-滑动窗口（时间换空间）"><a href="#解法二：排序-滑动窗口（时间换空间）" class="headerlink" title="解法二：排序+滑动窗口（时间换空间）"></a>解法二：排序+滑动窗口（时间换空间）</h2><p>其实在思考的过程中也想到可以用滑动窗口来解，但是没有想到排序这一步。</p><p>首先对数组排序，然后使用一个指针<code>start</code>标识滑窗的起点，另一个指针<code>i</code>标识终点。当两个指针没有相遇时，如果滑窗的终点减去滑窗的起点的值大于1，就将滑窗的起点应向前移动，这个移动过程会在指针相遇或者滑窗起点与滑窗终点的差值小于等于1时结束。如果差值等于1，那么我们就找到了一个和谐子序列。记录最大值的方法与哈希表解法相同。</p><pre><code class="go">func findLHS(nums []int) int &#123;    sort.Ints(nums)    ans, start := 0, 0    for i := 0; i &lt; len(nums); i++ &#123;        for start &lt; i &amp;&amp; nums[i]-nums[start] &gt; 1 &#123;            start++        &#125;        if nums[i]-nums[start] == 1 &#123;            if i-start+1 &gt; ans &#123;                ans = i - start + 1            &#125;        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>64 ms</strong>（超过32.94%的Golang提交记录）</p><p>内存消耗: <strong>6.6 MB</strong>（超过87.68%的Golang提交记录）</p><p>时间复杂度：O(nlogn)，排序的时间复杂度为O(nlogn)，滑窗的时间复杂度为O(n)，算法整体的时间复杂度为O(nlogn)；</p><p>空间复杂度：O(logn)，排序的空间复杂度为O(logn)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>509.斐波那契数</title>
      <link href="/2021/11/22/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
      <url>/2021/11/22/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></p><h2 id="解法：记忆化搜索（动态规划-状态压缩）"><a href="#解法：记忆化搜索（动态规划-状态压缩）" class="headerlink" title="解法：记忆化搜索（动态规划+状态压缩）"></a>解法：记忆化搜索（动态规划+状态压缩）</h2><p>这道题其实最简单的解法是递归，大家应该也都会写，但是递归99%会TLE，所以需要找点省时间的办法。</p><p>由于每一个斐波那契数都可以用它的前两个数得出，所以只需要把前两个数存储下来然后循环迭代对应的次数即可求出答案。这其实就是动态规划的一种变体，也可以说是一种“记忆化搜索”，建议看这个：<a href="https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/">动态规划套路详解</a>，讲的非常非常详细。</p><p>当然，这题因为没有涉及求最值（最优子结构），所以不算完整意义上的动态规划，不过和1137一起拿来当动态规划的入门题、跟着前面提到的文章一步一步推出这个空间复杂度为O(1)的解法是再合适不过了。</p><pre><code class="go">func fib(n int) int &#123;    if n == 0 &#123;        return 0    &#125;    if n == 1 &#123;        return 1    &#125;    pre, cur := 0, 1    for i := 2; i &lt;= n; i++ &#123;        j := pre + cur        pre = cur        cur = j    &#125;    return cur&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(n)，除了求0和1之外都需要遍历<code>n - 1</code>次才能计算出答案；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>453.最小操作次数使数组元素相等</title>
      <link href="/2021/11/22/453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/"/>
      <url>/2021/11/22/453-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="453-最小操作次数使数组元素相等"><a href="#453-最小操作次数使数组元素相等" class="headerlink" title="453. 最小操作次数使数组元素相等"></a>453. 最小操作次数使数组元素相等</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. 最小操作次数使数组元素相等</a></p><h2 id="解法：求所有元素与数组最小元素之间的差值"><a href="#解法：求所有元素与数组最小元素之间的差值" class="headerlink" title="解法：求所有元素与数组最小元素之间的差值"></a>解法：求所有元素与数组最小元素之间的差值</h2><p>这道题与其说是算法，不如说是考察逆向思维的脑筋急转弯吧。。。</p><p>其实思路很简单：每次操作使<code>n - 1</code>个元素增加1，那么效果其实就相当于让数组中最大的数减1，所以只要先求出数组中的最小值，再求所有元素与这个最小值的差，最后把这些差都加起来就是我们需要的答案了。</p><p>如果不明白的话可以看官方题解，讲得很清楚。</p><pre><code class="go">func minMoves(nums []int) int &#123;    min := nums[0]    // 找出数组中的最小值    for _, v := range nums &#123;        if v &lt; min &#123;            min = v        &#125;    &#125;    // 计算数组中所有元素与数组最小值的差值    ans := 0    for _, v := range nums &#123;        ans += v - min    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>32 ms</strong>（超过93.58%的Golang提交记录）</p><p>内存消耗: <strong>6.6 MB</strong>（超过90.83%的Golang提交记录）</p><p>时间复杂度：O(n)，需要一次遍历求出数组中的最小值，还需要一次遍历求出数组中的值与最小值的差；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 脑筋急转弯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>441.排列硬币</title>
      <link href="/2021/11/22/441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/"/>
      <url>/2021/11/22/441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<h1 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441. 排列硬币"></a>441. 排列硬币</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/arranging-coins">441. 排列硬币</a></p><h2 id="解法1：暴力迭代（最容易实现）"><a href="#解法1：暴力迭代（最容易实现）" class="headerlink" title="解法1：暴力迭代（最容易实现）"></a>解法1：暴力迭代（最容易实现）</h2><p>本题最容易实现的办法就是设置一个计数器记录行数，每次循环给计数器加1并从总数中减去计数器的值，直到计数器的值比总数大时跳出循环。</p><pre><code class="go">func arrangeCoins(n int) int &#123;    if n &lt;= 1 &#123;        return 1    &#125;    m := 1    for n &gt;= m &#123;        n -= m        m++    &#125;    return m - 1&#125;</code></pre><p>执行用时: <strong>8 ms</strong>（超过40%的Golang提交记录）</p><p>内存消耗: <strong>2.2 MB</strong>（超过61%的Golang提交记录）</p><p>时间复杂度：O(n)，for循环的执行次数与n成正比；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：二分-等差数列求和（最容易想到）"><a href="#解法2：二分-等差数列求和（最容易想到）" class="headerlink" title="解法2：二分+等差数列求和（最容易想到）"></a>解法2：二分+等差数列求和（最容易想到）</h2><p>看到这道题的第一反应就是等差数列求和，求和公式为<code>(i * (i + 1)) / 2</code>，但是没有想到这个求和公式该怎么用于是改用解法1，把解法1写出来之后看了官方题解才明白原来本题中等差数列求和需要配合二分查找来使用。</p><pre><code class="go">func arrangeCoins(n int) int &#123;    return sort.Search(n, func(i int) bool &#123;        i++        return i * (i + 1) &gt; 2 * n    &#125;)&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过73%的Golang提交记录）</p><p>内存消耗: <strong>2.2 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法3：等差数列求和-求根公式（效率最高）"><a href="#解法3：等差数列求和-求根公式（效率最高）" class="headerlink" title="解法3：等差数列求和+求根公式（效率最高）"></a>解法3：等差数列求和+求根公式（效率最高）</h2><p>这种解法是从官方题解中看到的，详细解法可以看官方题解，大概就是使用等差数列求和公式列方程并解一元二次方程。不得不说这是一种十分聪明的解法，明明是初中数学知识结果很难想到可以应用在这道题里😿</p><pre><code class="go">func arrangeCoins(n int) int &#123;    return int((math.Sqrt(float64(8*n + 1)) - 1) / 2)&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.2 MB</strong>（超过99.25%的Golang提交记录）</p><p>时间复杂度：O(1)，不考虑<code>math.Sqrt()</code>函数的内部实现的话该算法的执行效率不受问题规模的影响；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>430.扁平化多级双向链表</title>
      <link href="/2021/11/22/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/22/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a>430. 扁平化多级双向链表</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></p><h2 id="解法：递归-DFS"><a href="#解法：递归-DFS" class="headerlink" title="解法：递归+DFS"></a>解法：递归+DFS</h2><p>虽然这道题也可以使用迭代+栈来解，但不得不说递归是本题最简单易懂的一种思路。</p><p>根据题意，我们可以知道在扁平化后的双向链表里，<code>child</code>指向的链表是先于<code>next</code>指向的链表出现的，也就是说，如果结点的<code>child</code>字段不为<code>nil</code>，我们就需要先遍历<code>child</code>字段指向的链表并将其加入到答案中，然后返回<code>child</code>链表开头的结点继续向后遍历，直到<code>next</code>和<code>child</code>都为<code>nil</code>则停止遍历。据此不难看出我们可以使用<code>DFS</code>的变体来解决这道题目，而<code>DFS</code>最简单易懂的实现方式就是递归。</p><p>递归的实现思路如下：</p><ul><li>如果当前结点为<code>nil</code>则表明到达了递归边界，返回；</li><li>根据当前遍历到的结点信息生成一个结点，并将其挂在答案链表上（答案链表的尾结点作为函数参数<code>pre</code>传入）；</li><li>如果<code>child</code>字段不为空，说明该结点有子链表，递归遍历该子链表并使用函数返回值带回答案链表的尾结点地址<code>cur</code>以便后续求解；</li><li>如果<code>child</code>字段为<code>nil</code>，则递归遍历该结点的后续结点，直到达到递归边界。</li></ul><p>由于此题使用带头结点的双向链表求解更方便，所以在第一次调用<code>dfs()</code>函数前需要初始化头结点并将之后的结点都挂在头结点后，在返回答案前还需要把头结点从答案链表中摘除以免产生错误答案。</p><pre><code class="go">/** * Definition for a Node. * type Node struct &#123; *     Val int *     Prev *Node *     Next *Node *     Child *Node * &#125; */var head = &amp;Node&#123;Val: 0, Prev: nil, Next: nil, Child: nil&#125;func flatten(root *Node) *Node &#123;    if root == nil &#123;        return &amp;Node&#123;Val: 0, Prev: nil, Next: nil, Child: nil&#125;    &#125;    // 初始化头结点    head = &amp;Node&#123;Val: 0, Prev: nil, Next: nil, Child: nil&#125;    // 递归    dfs(root, head)    // 把头结点从链表里摘掉,然后返回得到的链表    ans := head.Next    ans.Prev = nil    return ans&#125;func dfs(node *Node, pre *Node) *Node &#123;    if node != nil &#123;        // 把当前遍历到的结点挂到要返回的链表上        cur := &amp;Node&#123;Val: node.Val, Prev: pre, Next: nil, Child: nil&#125;        pre.Next = cur        // 如果有子结点则先遍历子结点        if node.Child != nil &#123;            cur = dfs(node.Child, cur)        &#125;        // 如果没有子结点就遍历下一个结点        dfs(node.Next, cur)        return cur    &#125;    return nil&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>3 MB</strong>（超过20%的Golang提交记录）</p><p>时间复杂度：O(n)，递归的执行次数等于链表中结点的个数；</p><p>空间复杂度：O(n)，递归工作栈所占用的内存空间与问题规模（链表长度）成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326.3的幂</title>
      <link href="/2021/11/22/326-3%E7%9A%84%E5%B9%82/"/>
      <url>/2021/11/22/326-3%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a>326. 3的幂</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></p><h2 id="解法：循环"><a href="#解法：循环" class="headerlink" title="解法：循环"></a>解法：循环</h2><p>最简单的方法当然是循环，每次循环都判断一下当前的数是否可以被3整除，可以的话将其除以3，直到该数为1时跳出循环。不使用循环的数论解法一般考不到（其实也不难啦，看题解之前一般想不到但是看了题解很容易懂，就是判断这个数能不能被<code>int</code>范围内最大的是3的幂的数<code>1162261467</code>整除即可，0或负数的情况需要特殊判断）。</p><p>当然不使用循环的解法除了数论，还有其他一些方法：打表、暴力枚举等，这些方法评论区很多大佬都写过了，这里就不写了。</p><pre><code class="go">func isPowerOfThree(n int) bool &#123;    if n &lt;= 0 &#123;        return false    &#125;    for n &gt; 1 &#123;        if n % 3 != 0 &#123;            return false        &#125; else &#123;            n /= 3        &#125;    &#125;    return true&#125;</code></pre><p>执行用时: <strong>40 ms</strong>（超过23%的Golang提交记录）</p><p>内存消耗: <strong>6.4 MB</strong>（超过40%的Golang提交记录）</p><p>时间复杂度：O(logn)，因为每次循环都会将数字除以3，所以需要循环的次数是以3为底n的对数次；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>310.最小高度树</title>
      <link href="/2021/11/22/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"/>
      <url>/2021/11/22/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a>310. 最小高度树</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a></p><h2 id="解法：拓扑排序"><a href="#解法：拓扑排序" class="headerlink" title="解法：拓扑排序"></a>解法：拓扑排序</h2><p>这道题其实也可以使用DFS来求解（大多数人想到的第一个解法也都是DFS求出所有结点为根的树高并找到最小的那几个吧），但时间复杂度（O(n^2)）不如使用拓扑排序（O(n)）更优秀。</p><p>那我们是如何想到可以使用拓扑排序的呢？可以这样想：可以生成最小高度的树的结点一定是图中比较“靠中间”的结点，所以只需要不断删除图中度为1的结点就可以找到这些“靠中间”的结点，而这个不断删除度为1的结点的过程是不是很像拓扑排序呢？只不过拓扑排序针对的是有向图（AOE网）而本题是无向图，但思路是完全一样的。</p><p>实现起来也不难，根据题目中的输入建立图，然后对该图进行拓扑排序，返回最后一轮出队的结点即可。</p><pre><code class="go">func findMinHeightTrees(n int, edges [][]int) []int &#123;    if n == 1 &#123;        return []int&#123;0&#125;    &#125;    ans := make([]int, 0)    // 保存所有顶点的度    degree := make([]int, n)    // 邻接表(key为顶点,value是一个数组,保存与该顶点有边相连的顶点)    graph := make(map[int][]int)    // 遍历所有的边,计算所有顶点的度,并且建立邻接表    for i := 0; i &lt; len(edges); i++ &#123;        // 为每条边两边的结点增加1个度        degree[edges[i][1]]++        degree[edges[i][0]]++        // 将这个顶点连接到的边保存在map里        graph[edges[i][0]] = append(graph[edges[i][0]], edges[i][1])        graph[edges[i][1]] = append(graph[edges[i][1]], edges[i][0])    &#125;    // 预处理:把所有度为1的结点入队    q := make([]int, 0)    for i := 0; i &lt; n; i++ &#123;        if degree[i] == 1 &#123;            q = append(q, i)        &#125;    &#125;    // 拓扑排序:不断删除入度为1的结点,直到队列为空    for len(q) &gt; 0 &#123;        // 因为求的是最后一轮遍历所删除的结点,所以每一轮都需要把数组清空一下        // 这样遍历结束的时候数组中就是最后一轮的结点,也就是题目要求的结点        ans = make([]int, 0)        l := len(q)        for j := 0; j &lt; l; j++ &#123;            poped := q[0]            q = q[1:]            ans = append(ans, poped)            // 遍历邻接于该顶点的所有顶点,把它们的度都减1,遇到度为1的结点则入队            for _, node := range graph[poped] &#123;                degree[node]--                if degree[node] == 1 &#123;                    q = append(q, node)                &#125;            &#125;        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>36 ms</strong>（超过57%的Golang提交记录）</p><p>内存消耗: <strong>8.6 MB</strong>（超过11%的Golang提交记录）</p><p>时间复杂度：O(n)，拓扑排序时<code>for</code>循环的执行次数与边的数量成正比；</p><p>空间复杂度：O(n)，建立图所需要的空间与边的数量成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283.移动零</title>
      <link href="/2021/11/22/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2021/11/22/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></p><h2 id="解法1：将所有非零元素移动到数组前并在其余位置填0"><a href="#解法1：将所有非零元素移动到数组前并在其余位置填0" class="headerlink" title="解法1：将所有非零元素移动到数组前并在其余位置填0"></a>解法1：将所有非零元素移动到数组前并在其余位置填0</h2><p>题目要求空间复杂度为O(1)，所以不能使用额外的数组，但是我们可以换过来想一下：能不能复用题目中的数组呢？答案当然是可以的：</p><ul><li>使用一个指针<code>i</code>从数组头部开始扫描，使用另一个指针<code>j</code>指向数组第一个元素；</li><li>每当<code>i</code>遇到非0元素时，就将其复制到<code>j</code>所指向的位置，并把<code>j</code>向后移动一位；</li><li>当<code>i</code>遍历完成后，把<code>j</code>当前指向的位置及其之后的所有位置都填上0即可。</li></ul><pre><code class="go">func moveZeroes(nums []int)  &#123;    n := len(nums)    i, j := 0, 0    for i &lt; n &#123;        if nums[i] != 0 &#123;            nums[j] = nums[i]            j++        &#125;        i++    &#125;    for j &lt; n &#123;        nums[j] = 0        j++    &#125;&#125;</code></pre><p>执行用时: <strong>24 ms</strong>（超过10.37%的Golang提交记录）</p><p>内存消耗: <strong>6.6 MB</strong>（超过21.50%的Golang提交记录）</p><p>时间复杂度：O(n)，两个<code>for</code>循环的执行次数为数组的长度；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：官方双指针解法"><a href="#解法2：官方双指针解法" class="headerlink" title="解法2：官方双指针解法"></a>解法2：官方双指针解法</h2><p>官方解法是双指针的另一种使用方法：</p><ul><li>设置两个指针<code>i</code>和<code>j</code>，两个指针最初都指向数组的首个元素；</li><li>将<code>j</code>从头开始扫描，遇到非0的数则将<code>i</code>和<code>j</code>指向的数相互交换，并将<code>i</code>向后移动一位；</li><li><code>j</code>扫描完整个数组后处理完成。</li></ul><pre><code class="go">func moveZeroes(nums []int)  &#123;    i, j, n := 0, 0, len(nums)    for j &lt; n &#123;        if nums[j] != 0 &#123;            nums[i], nums[j] = nums[j], nums[i]            i++        &#125;        j++    &#125;&#125;</code></pre><p>执行用时: <strong>24 ms</strong>（超过10.37%的Golang提交记录）</p><p>内存消耗: <strong>6.6 MB</strong>（超过15.43%的Golang提交记录）</p><p>时间复杂度：O(n)，<code>for</code>循环的执行次数为数组的长度；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278.第一个错误的版本</title>
      <link href="/2021/11/22/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2021/11/22/278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></p><h2 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h2><p>这道题虽然看起来很绕，但本质上就是个简单的二分查找变体而已。因为这题要求的是第一个错误的版本，所以在判断错误版本时要让<code>r = m</code>，并且判断条件要改成<code>l &lt; r</code>，这样最后会在<code>l == r</code>时退出循环，此时返回的<code>r</code>就是第一个错误版本。</p><p>通过这题学到一招：在二分查找中，使用公式<code>l + (r - l) / 2</code>来求<code>m</code>可以避免溢出的问题。</p><p>这里给出两种写法：</p><ol><li><strong>手写二分查找</strong></li></ol><pre><code class="go">/**  * Forward declaration of isBadVersion API. * @param   version   your guess about first bad version * @return                true if current version is bad  *                      false if current version is good * func isBadVersion(version int) bool; */func firstBadVersion(n int) int &#123;    l, r := 1, n    for l &lt; r &#123;        m := l + (r - l) / 2        if isBadVersion(m) &#123;            r = m        &#125; else &#123;            l = m + 1        &#125;    &#125;    return r&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><ol start="2"><li><strong>使用<code>sort.Search()</code>函数</strong></li></ol><pre><code class="go">/**  * Forward declaration of isBadVersion API. * @param   version   your guess about first bad version * @return                true if current version is bad  *                      false if current version is good * func isBadVersion(version int) bool; */func firstBadVersion(n int) int &#123;    return sort.Search(n, func(i int) bool &#123;        return isBadVersion(i)    &#125;)&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>275.H指数II</title>
      <link href="/2021/11/22/275-H%E6%8C%87%E6%95%B0II/"/>
      <url>/2021/11/22/275-H%E6%8C%87%E6%95%B0II/</url>
      
        <content type="html"><![CDATA[<h1 id="275-H指数II"><a href="#275-H指数II" class="headerlink" title="275. H指数II"></a>275. H指数II</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/h-index-ii/">275. H指数II</a></p><h2 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h2><p>这道题其实很简单，就是一个没什么技术含量的二分查找而已，但是这题的难点在于理解题意，即从这奇奇怪怪的题目描述里分析出这是一道考察二分查找的题目：数组是升序排列的，且查找的条件是<code>citations[mid] &gt;= len(citations) - mid</code>。</p><p>个人感觉这题一般，在考察二分的题目里质量不如658。</p><pre><code class="go">func hIndex(citations []int) int &#123;    n := len(citations)    if n == 0 &#123;        return 0    &#125;    l, r := 0, n - 1    for l &lt;= r &#123;        m := (l + r) / 2        if citations[m] &gt;= n - m &#123;            r = m - 1        &#125; else &#123;            l = m + 1        &#125;    &#125;    return n - l&#125;</code></pre><p>执行用时: <strong>16 ms</strong>（超过81%的Golang提交记录）</p><p>内存消耗: <strong>6.6 MB</strong>（超过99%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>231.2的幂</title>
      <link href="/2021/11/22/231-2%E7%9A%84%E5%B9%82/"/>
      <url>/2021/11/22/231-2%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/power-of-two/">231.2的幂</a></p><h2 id="解法：位运算"><a href="#解法：位运算" class="headerlink" title="解法：位运算"></a>解法：位运算</h2><p>如果一个正整数是2的幂，例如<code>8</code>（二进制表示为<code>1000</code>），那么它减去1之后的数，例如<code>7</code>（二进制表示为<code>111</code>）与它本身相与之后的结果一定是0。因为2的幂的二进制表示只有最高位为1而其他位都为0，而它减去1之后原来的最高位变为0，其他位变为1，两者相与就能得到0。</p><pre><code class="go">func isPowerOfTwo(n int) bool &#123;    if n &lt;= 0 &#123;        return false    &#125;    return (n &amp; (n - 1)) == 0&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.1 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(1)，不需要循环，问题的规模与算法执行效率无关；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>223.矩形面积</title>
      <link href="/2021/11/22/223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
      <url>/2021/11/22/223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223. 矩形面积"></a>223. 矩形面积</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积</a></p><h2 id="解法：面积之和-重叠面积"><a href="#解法：面积之和-重叠面积" class="headerlink" title="解法：面积之和-重叠面积"></a>解法：面积之和-重叠面积</h2><p>看到这道题你可能认为需要考虑各种情况（比如两个矩形有没有重叠，大矩形包小矩形会怎样等等）来求解了，其实仔细想想就能发现这题本质上就是求两个矩形的重叠面积，因为两个矩形的实际覆盖面积就是两个矩形的面积之和减去它们的重叠面积。那么问题就转化为如何求重叠部分的面积了。这也很简单，重叠面积的宽度<code>w</code>为<code>math.Min(ax2, bx2) - math.Max(ax1, bx1)</code>，高度<code>h</code>为<code>math.Min(ay2, by2) - math.Min(ay1, by1)</code>，若其中某一个为负数则将其置为0，求出<code>w</code>和<code>h</code>之后计算出两个矩形的面积并减去<code>w * h</code>就可以了。</p><p>注意：如果想继续优化的话，可以自己实现针对int类型的<code>min</code>和<code>max</code>两个函数，这样可以比频繁地进行类型转换更快一些。</p><pre><code class="go">func computeArea(ax1 int, ay1 int, ax2 int, ay2 int, bx1 int, by1 int, bx2 int, by2 int) int &#123;    // 求重叠部分的长和宽    w := math.Max(0, math.Min(float64(ax2), float64(bx2)) - math.Max(float64(ax1), float64(bx1)))    h := math.Max(0, math.Min(float64(ay2), float64(by2)) - math.Max(float64(ay1), float64(by1)))    // 实际覆盖面积 = 两个矩形的面积之和 - 重叠部分面积    return (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1) - (int(w) * int(h))&#125;</code></pre><p>执行用时: <strong>16 ms</strong>（超过40%的Golang提交记录）</p><p>内存消耗: <strong>6.2 MB</strong>（超过67%的Golang提交记录）</p><p>时间复杂度：O(1)，问题的规模与算法执行效率无关；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表</title>
      <link href="/2021/11/22/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/22/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p><h2 id="解法1：迭代（最优解）"><a href="#解法1：迭代（最优解）" class="headerlink" title="解法1：迭代（最优解）"></a>解法1：迭代（最优解）</h2><p>这道题最简单的解法当然是迭代了：设置两个指针<code>pre</code>和<code>cur</code>保存当前结点和下一个结点，每次使用一个<code>temp</code>变量保存原来的<code>cur.Next</code>，然后让<code>cur.Next</code>指向<code>pre</code>，并把<code>pre</code>更新为<code>cur</code>，最后把<code>cur</code>更新为<code>temp</code>并把<code>temp</code>向后移动一位，直到<code>cur</code>为<code>nil</code>时退出循环。</p><p>注意<code>pre</code>要初始化为<code>nil</code>，这样就不需要对链表长度为<code>0</code>或者<code>1</code>的情况做特殊判断。</p><pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;    var pre, cur *ListNode = nil, head    for cur != nil &#123;        temp := cur.Next        cur.Next = pre        pre = cur        cur = temp    &#125;    return pre&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.5 MB</strong>（超过99.91%的Golang提交记录）</p><p>时间复杂度：O(n)，<code>for</code>循环的执行次数为链表长度；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：栈（最容易想到）"><a href="#解法2：栈（最容易想到）" class="headerlink" title="解法2：栈（最容易想到）"></a>解法2：栈（最容易想到）</h2><p>事实上我最先想到的就是这个解法。虽然这道题显然迭代是最优解，但这种使用栈的解法在其他一些不能迭代的题中也会经常用到（例如二叉树的遍历的非递归写法，就跟这种使用栈的写法很类似），因为这种题目中使用栈本质上是递归的优化。</p><p>首先把链表所有的结点都入栈，然后依次弹出所有元素并且连成链表，直到栈为空时退出循环。注意最后需要把最后一个结点的<code>Next</code>置为<code>nil</code>，否则链表就会变成环。</p><pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;    // 空链表,不用反转直接返回nil    if head == nil &#123;        return nil    &#125;    // 一个结点的链表,也不用反转    if head.Next == nil &#123;        return head    &#125;    stack := make([]*ListNode, 0)    top := 0    // 把链表所有结点入栈    for p := head; p != nil; p = p.Next &#123;        stack = append(stack, p)        top++    &#125;    // 弹出第一个结点(原链表尾结点)    tail := stack[top-1]    top--    p := tail    for top != 0 &#123;        // 每次遍历弹出一个结点直到栈为空        p.Next = stack[top-1]        top--        p = p.Next    &#125;    p.Next = nil    return tail&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2.8 MB</strong>（超过24%的Golang提交记录）</p><p>时间复杂度：O(n)，<code>for</code>循环的执行次数为链表长度；</p><p>空间复杂度：O(n)，栈的最大深度为链表长度。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191.位1的个数</title>
      <link href="/2021/11/22/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/11/22/191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></p><h2 id="解法：位运算"><a href="#解法：位运算" class="headerlink" title="解法：位运算"></a>解法：位运算</h2><p>读过《剑指Offer》的应该都知道这题的做法。</p><blockquote><p>如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1。先假设这个数的最右边一位是1，那么减去1时，最后一位变成0而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由1变成了0。</p><p>接下来假设最后一位不是1而是0的情况。如果该整数的二进制表示中最右边1位于第m位，那么减去1时，第m位由1变成0，而第m位之后的所有0都变成1，整数中第m位之前的所有位都保持不变。</p><p>…</p><p>接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。</p><p>我们把上面的分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就困产不行多少次这样的操作。</p><p>——《剑指Offer》</p></blockquote><pre><code class="go">func hammingWeight(num uint32) int &#123;    ans := 0    for ; num &gt; 0; num = (num - 1) &amp; num &#123;        ans++    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过59.73%的Golang提交记录）</p><p>时间复杂度：O(logn)，循环次数等于n的二进制位中1的个数，例如对于7（111）需要循环3次。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189.旋转数组</title>
      <link href="/2021/11/22/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2021/11/22/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></p><h2 id="解法：分段旋转"><a href="#解法：分段旋转" class="headerlink" title="解法：分段旋转"></a>解法：分段旋转</h2><p>这道题其实和剑指Offer的58题挺像，但是需要把旋转过程反过来：</p><ol><li>旋转整个数组</li><li>旋转<code>0~k</code>位</li><li>旋转<code>k+1~len(nums)-1</code>位</li></ol><pre><code class="go">// k = 3// 1 2 3 4 5 6 7 8// 8 7 6 5 4 3 2 1 反转整个数组// 6 7 8 5 4 3 2 1 反转字符串前k位// 6 7 8 1 2 3 4 5 反转k位到末位func rotate(nums []int, k int) &#123;    k %= len(nums)    reverse(nums)    reverse(nums[:k])    reverse(nums[k:])&#125;func reverse(arr []int) &#123;    i, j := 0, len(arr)-1    for i &lt; j &#123;        temp := arr[i]        arr[i] = arr[j]        arr[j] = temp        i++        j--    &#125;&#125;</code></pre><p>执行用时: <strong>32 ms</strong>（超过18.83%的Golang提交记录）</p><p>内存消耗: <strong>7.9 MB</strong>（超过98.79%的Golang提交记录）</p><p>时间复杂度：O(n)，需要遍历两次整个数组；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>187.重复的DNA序列</title>
      <link href="/2021/11/22/187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97/"/>
      <url>/2021/11/22/187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a>187. 重复的DNA序列</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></p><h2 id="解法1：哈希表（最容易想到）"><a href="#解法1：哈希表（最容易想到）" class="headerlink" title="解法1：哈希表（最容易想到）"></a>解法1：哈希表（最容易想到）</h2><p>对于这道题，一个很容易想到的方法就是从字符串开头统计出所有长度为10的字串放入哈希表（key为字串，value为出现次数），向后遍历时将每个长度为10的字串都与哈希表中已有的字符串进行比较，如果该字符串在哈希表里已经出现过就将该字串加入到答案集合中，否则将该字串作为key放入哈希表并置其value为1。</p><pre><code class="go">func findRepeatedDnaSequences(s string) []string &#123;    l := 10    m := make(map[string]int, 0)    ans := make([]string, 0)    for i := 0; i &lt;= len(s)-l; i++ &#123; // 注意这里，需要用&lt;=，否则就会漏判一位导致答案错误        str := s[i : i+10]        m[str]++        if m[str] == 2 &#123;            ans = append(ans, str)        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>12 ms</strong>（超过90%的Golang提交记录）</p><p>内存消耗: <strong>9.4 MB</strong>（超过34%的Golang提交记录）</p><p>时间复杂度：O(n * L)，for循环的执行次数与n成线性相关，并且计算字符串哈希需要消耗的时间与字符串长度L成正比；</p><p>空间复杂度：O(n)，map需要占用的存储空间与字符串长度成正比。</p><h2 id="解法2：位运算-自定义哈希（效率高）"><a href="#解法2：位运算-自定义哈希（效率高）" class="headerlink" title="解法2：位运算+自定义哈希（效率高）"></a>解法2：位运算+自定义哈希（效率高）</h2><p>由于该题的字符串只有A、G、C、T四种字符组成，所以我们可以使用自定义哈希的方法来减少计算哈希的时间和存储哈希所用的空间。如果采用00、01、10、11来编码四个字符，那么使用一个int就可以存下整个长度为10的字符串，这样可以大大提高算法的效率。但是如果只做这样的优化，对时间复杂度的提升是比较小的，进一步优化的思路则是利用位运算加快计算。设使用一个20位的空间来表示长度为10的字符串的哈希值，那么每向后运算一位，就将这个整数左移2位并将高于20位的字符清零（<code>w = w &lt;&lt; 2 &amp; 1 &lt;&lt; 20 - 1</code>），再将新的字符的哈希填入这个20位的空间的低2位（<code>w |= h[c]</code>，其中<code>h[c]</code>为字符<code>c</code>的自定义哈希）。</p><pre><code class="go">// 自定义哈希表var h = map[byte]int&#123;&#39;A&#39;: 0, &#39;C&#39;: 1, &#39;G&#39;: 2, &#39;T&#39;: 3&#125;func findRepeatedDnaSequences(s string) []string &#123;    // 长度小于等于10的字符串中是肯定不会出现长度为10的重复字串的    if len(s) &lt;= 10 &#123;        return []string&#123;&#125;    &#125;    w := 0    // 准备工作: 计算出前10位的哈希,填入准备好的空间中    for _, c := range s[:9] &#123;        w = w&lt;&lt;2 | h[byte(c)]    &#125;    ans := make([]string, 0)    m := map[int]int&#123;&#125;    // 计算哈希,找出符合要求的字串    for i := 0; i &lt;= len(s)-10; i++ &#123;        w = (w&lt;&lt;2 | h[s[i+9]]) &amp; (1&lt;&lt;20 - 1)        m[w]++        if m[w] == 2 &#123;            ans = append(ans, s[i:i+10])        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>16 ms</strong>（超过73%的Golang提交记录）</p><p>内存消耗: <strong>8.9 MB</strong>（超过87%的Golang提交记录）</p><p>时间复杂度：O(n)，for循环的执行次数与n成线性相关；</p><p>空间复杂度：O(n)，map需要占用的存储空间与字符串长度成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167.两数之和II</title>
      <link href="/2021/11/22/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/"/>
      <url>/2021/11/22/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/</url>
      
        <content type="html"><![CDATA[<h1 id="167-两数之和II"><a href="#167-两数之和II" class="headerlink" title="167. 两数之和II"></a>167. 两数之和II</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和II</a></p><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>这道题我们当然也可以用1的解法（暴力求解（时间换空间）或者哈希表（空间换时间））来求解，但是这两个解法没有用到“数组有序”这个条件，在数组有序的条件下，我们有更好的解法：双指针。</p><ul><li>定义两个指针<code>i</code>和<code>j</code>，初始时<code>i</code>指向数组的第一个元素，<code>j</code>指向数组的最后一个元素；</li><li>每次循环都比较<code>numbers[i] + numbers[j]</code>与<code>target</code>的大小关系：<ul><li>相等，说明找到了目标值，返回<code>[]int&#123;i + 1, j + 1&#125;</code>（题目中需要返回的是位序，即下标加1）；</li><li><code>numbers[i] + numbers[j] &gt; target</code>，说明其中一个数应该更小，把<code>j</code>向前移动一位；</li><li><code>numbers[i] + numbers[j] &lt; target</code>，说明其中一个数应该更大，把<code>i</code>向后移动一位。</li></ul></li><li>直到<code>i</code>和<code>j</code>相遇为止，不过输入范围已经明确了数组中一定存在有效答案，所以两个指针实际上不可能相遇就已经返回了。</li></ul><pre><code class="go">func twoSum(numbers []int, target int) []int &#123;    i, j := 0, len(numbers) - 1    for i &lt; j &#123;        if numbers[i] + numbers[j] == target &#123;            return []int&#123;i + 1, j + 1&#125;        &#125; else if numbers[i] + numbers[j] &lt; target &#123;            i++        &#125; else &#123;            j--        &#125;    &#125;    return []int&#123;i + 1, j + 1&#125;&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了88.85%的用户；</p><p>内存消耗：3 MB, 在所有 Go 提交中击败了100.00%的用户；</p><p>时间复杂度：O(n)，最坏的情况下<code>for</code>循环执行次数等于数组长度；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94.二叉树的中序遍历</title>
      <link href="/2021/11/22/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/11/22/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><blockquote><p>这道题是非常非常基础的算法题，大家数据结构课上应该都已经学过了，递归和非递归的写法应该也都背的滚瓜烂熟了，这里就展示一下两种方法的Go语言写法和执行效率吧。</p></blockquote><h2 id="解法1：递归（最简单）"><a href="#解法1：递归（最简单）" class="headerlink" title="解法1：递归（最简单）"></a>解法1：递归（最简单）</h2><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var ans = make([]int, 0)func inorderTraversal(root *TreeNode) []int &#123;    ans = make([]int, 0)    if root != nil &#123;        doInorderTraversal(root)    &#125;    return ans&#125;func doInorderTraversal(tree *TreeNode) &#123;    if tree != nil &#123;        doInorderTraversal(tree.Left)        ans = append(ans, tree.Val)        doInorderTraversal(tree.Right)    &#125;&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2 MB</strong>（超过67%的Golang提交记录）</p><p>时间复杂度：O(n)，递归函数<code>doInorderTraversal()</code>的执行次数等于树中结点个数；</p><p>空间复杂度：O(n)，递归工作栈的深度与树高成正比。</p><h2 id="解法2：非递归（效率高）"><a href="#解法2：非递归（效率高）" class="headerlink" title="解法2：非递归（效率高）"></a>解法2：非递归（效率高）</h2><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func inorderTraversal(root *TreeNode) []int &#123;    if root == nil &#123;        return []int&#123;&#125;    &#125;    ans := make([]int, 0)    stack := make([]*TreeNode, 0)    p := root    for len(stack) &gt; 0 || p != nil &#123;        for p != nil &#123;            stack = append(stack, p)            p = p.Left        &#125;        if len(stack) &gt; 0 &#123;            p = stack[len(stack)-1]            stack = stack[:len(stack)-1]            ans = append(ans, p.Val)            p = p.Right        &#125;    &#125;    return ans&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2 MB</strong>（超过100%的Golang提交记录）</p><p>时间复杂度：O(n)，<code>for</code>循环的执行次数等于树中结点个数；</p><p>空间复杂度：O(n)，辅助栈使用的空间与树高成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70.爬楼梯</title>
      <link href="/2021/11/22/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2021/11/22/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></p><h2 id="解法：记忆化搜索（动态规划-状态压缩）"><a href="#解法：记忆化搜索（动态规划-状态压缩）" class="headerlink" title="解法：记忆化搜索（动态规划+状态压缩）"></a>解法：记忆化搜索（动态规划+状态压缩）</h2><p>这道题一看就老眼熟了，实际上就是求斐波那契数列的前<code>n</code>项和，也是动态规划入门题。注意本题与509的不同：因为输入是从<code>1</code>开始，所以我们可以从3而不是2开始循环计算。</p><pre><code class="go">func climbStairs(n int) int &#123;    if n == 1 &#123;        return 1    &#125;    if n == 2 &#123;        return 2    &#125;    pre, cur := 1, 2    for i := 3; i &lt;= n; i++ &#123;        j := pre + cur        pre = cur        cur = j    &#125;    return cur&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>1.9 MB</strong>（超过76.09%的Golang提交记录）</p><p>时间复杂度：O(n)，除了求1和2之外都需要遍历<code>n - 1</code>次才能计算出答案；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66.加一</title>
      <link href="/2021/11/22/66-%E5%8A%A0%E4%B8%80/"/>
      <url>/2021/11/22/66-%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></p><h2 id="解法一：对整个数组做模拟加法（最容易想到）"><a href="#解法一：对整个数组做模拟加法（最容易想到）" class="headerlink" title="解法一：对整个数组做模拟加法（最容易想到）"></a>解法一：对整个数组做模拟加法（最容易想到）</h2><p>题目中给出的数据范围显然在转换成整数之后会超过<code>uint64</code>类型的范围，所以只能用模拟加法来解决这个问题，基本解题思路和<code>2. 两数相加</code>基本一致，注意在遍历完之后还需要看看进位标记<code>carry</code>是否为1，如果是，则需要在切片前面填上一个1再返回。</p><p>这里0做了特殊判断，后来发现没有这个必要，所以把第一个<code>if</code>删了也能过。</p><pre><code class="go">func plusOne(digits []int) []int &#123;    if digits[0] == 0 &#123;        return []int&#123;1&#125;    &#125;    carry := 1    for i := len(digits) - 1; i &gt;= 0; i-- &#123;        if digits[i] + carry &gt;= 10 &#123;            digits[i] = (digits[i] + carry) % 10            carry = 1        &#125; else &#123;            digits[i] = digits[i] + carry            carry = 0        &#125;    &#125;    if carry == 1 &#123;        return append([]int&#123;1&#125;, digits...)    &#125; else &#123;        return digits    &#125;&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2 MB</strong>（超过95.81%的Golang提交记录）</p><p>时间复杂度：O(n)，在做模拟加法时对于长度为<code>n</code>的数组需要遍历<code>n</code>次；</p><p>空间复杂度：O(1)，不考虑返回值的话只使用了常数个数的存储空间。</p><h2 id="解法二：找出最长的后缀9（官方解法）"><a href="#解法二：找出最长的后缀9（官方解法）" class="headerlink" title="解法二：找出最长的后缀9（官方解法）"></a>解法二：找出最长的后缀9（官方解法）</h2><p>这个解法总体上执行效率要比解法1快一些，因为我们只需要找到数组中有多少个后缀9（即：数组的末尾有多少个9），边找边把这些9改成0，最后根据<code>p</code>的值判断接下来该执行什么操作：</p><ol><li><code>p == -1</code>，说明整个数组全是9，那么需要在开头填上一个1表示进一位；</li><li><code>p == len(digits) - 1</code>，说明整个数组没有后缀9，那么直接把最后一位加1即可；</li><li>其他的情况，说明数组中有后缀9但不全是9，那么将最后一个后缀9前面的第一个非9元素加1。</li></ol><p>我的写法比官方题解麻烦一点，不过应该更好懂。</p><pre><code class="go">func plusOne(digits []int) []int &#123;    p := len(digits) - 1    // 该for循环会在最后一个后缀9的前一位退出,如果全是9,则会在-1处退出    for p = len(digits) - 1; p &gt;= 0 &amp;&amp; digits[p] == 9; p-- &#123;        digits[p] = 0    &#125;    // 数组全是9的情况,在切片前面加一个1返回    if p == -1 &#123;        return append([]int&#123;1&#125;, digits...)    &#125;    // 没有后缀9的情况,直接把最后一位加1返回    if p == len(digits) - 1 &#123;        digits[len(digits) - 1] += 1        return digits    &#125;    // 其他情况,把p对应的数加1,因为我们已经把后缀9都改成0了,所以加1后直接返回即可    digits[p] += 1    return digits&#125;</code></pre><p>执行用时: <strong>0 ms</strong>（超过100%的Golang提交记录）</p><p>内存消耗: <strong>2 MB</strong>（超过95.81%的Golang提交记录）</p><p>时间复杂度：O(n)，遍历的次数与后缀9的个数有关；</p><p>空间复杂度：O(1)，不考虑返回值的话只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2021/11/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/11/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h2><p>抽象工厂模式的定义如下：</p><blockquote><p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p><p>为创建一组相关或者相互依赖的对象提供一个接口，而且无须指定它们的具体类。</p><p>——《设计模式之禅》</p></blockquote><p>好吧，就跟它的名字一样，它的定义也很抽象，很让人摸不着头脑。但其实这种设计模式还是很好理解的，只要明白了它和工厂模式有什么区别，再看一些实例代码，理解这种设计模式并不是难事。我们接下来就来具体讲讲它。</p><h2 id="抽象工厂模式和工厂模式的区别"><a href="#抽象工厂模式和工厂模式的区别" class="headerlink" title="抽象工厂模式和工厂模式的区别"></a>抽象工厂模式和工厂模式的区别</h2><p>首先考虑一个问题：抽象工厂模式和工厂模式的区别在哪？</p><p>抽象工厂模式最大的特征就是定义中提到的“相关或相互依赖的对象”，通俗点说，就是抽象工厂模式相比工厂模式多了两个概念：“<strong>产品族</strong>”和“<strong>等级结构</strong>”。工厂模式中的每个工厂只能生产一种产品，而抽象工厂模式将某些相关、等级结构不同的产品组成了一个“产品族”，然后用一个工厂来统一生产。</p><p>还是觉得很难理解？好的，Show you code！</p><h2 id="抽象工厂模式的简单例子"><a href="#抽象工厂模式的简单例子" class="headerlink" title="抽象工厂模式的简单例子"></a>抽象工厂模式的简单例子</h2><p>这里我没有使用《设计模式之禅》的例子，因为它比较复杂，我们来举个更简单更好理解的例子：</p><p>我们可以把Web应用简单地看做是由前端（客户端）和后端（服务端）组成的，不知道在看我的文章的同学中有没有知道“前端架构师”这个职业的同学，我们一直以为做后端开发更容易成为架构师，但是当前端变得越来越复杂时，前端架构师这种职位也就产生了。所以，在这个例子中，我们把架构师分为“前端架构师”和“后端架构师”两类。当然，要开发一个完整的Web应用，光有架构师还不行，还得有程序员来把架构师给出的设计用代码实现，而我们都知道程序员有做前端开发的，也有做后端开发的，这样也可以把程序员分为“前端程序员”和“后端程序员”两类。</p><p>在这个场景中，我们有四种产品：前端程序员、前端架构师、后端程序员、后端架构师。我们可以把“前端”和“后端”分为两个不同的<strong>等级结构</strong>，我们可以为这两个等级结构创建两个工厂类<code>FrontEndFactory</code>和<code>BackEndFactory</code>，我们同时也可以把“程序员”和“架构师”分为另外两个不同的<strong>产品族</strong>，在每个工厂类里添加<code>CreateProgrammer()</code>和<code>CreateArchitect()</code>两个方法用于创建程序员和架构师的实例——也就是说，<strong>有多少个产品族，在抽象工厂类里就有多少个创建方法</strong>。</p><p>根据这个场景我们可以画出下面这张UML类图（稍微有点不太标准，不过能通过这张图把上面描述的场景搞懂就OK了）：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20210917005502.png"></p><p>接下来用代码实现它：</p><p><strong>abstract_factory/programmer_factory.go</strong></p><pre><code class="go">package abstract_factoryimport &quot;fmt&quot;// Programmer 程序员总称type Programmer interface &#123;    Work() // 程序员都会工作&#125;// Architect 架构师总称type Architect interface &#123;    Design() // 架构师都会做架构设计&#125;// FrontEndArchitect 前端架构师type FrontEndArchitect struct&#123;&#125;func (a *FrontEndArchitect) Design() &#123;    fmt.Println(&quot;前端架构师做了一个页面秒开的设计&quot;)&#125;// FrontEndProgrammer 前端程序员type FrontEndProgrammer struct&#123;&#125;func (p *FrontEndProgrammer) Work() &#123;    fmt.Println(&quot;前端程序员在用WebStorm写TypeScript代码&quot;)&#125;// BackEndArchitect 后端架构师type BackEndArchitect struct&#123;&#125;func (a *BackEndArchitect) Design() &#123;    fmt.Println(&quot;后端架构师做了一个可以抗住上万并发的设计&quot;)&#125;// BackEndProgrammer 后端程序员type BackEndProgrammer struct&#123;&#125;func (p *BackEndProgrammer) Work() &#123;    fmt.Println(&quot;后端程序员在用GoLand写Golang代码&quot;)&#125;// AbstractFactory 抽象工厂type AbstractFactory interface &#123;    CreateProgrammer() Programmer // 创建程序员    CreateArchitect() Architect   // 创建架构师&#125;// FrontEndFactory 前端工厂type FrontEndFactory struct&#123;&#125;func (f *FrontEndFactory) CreateProgrammer() Programmer &#123;    return &amp;FrontEndProgrammer&#123;&#125;&#125;func (f *FrontEndFactory) CreateArchitect() Architect &#123;    return &amp;FrontEndArchitect&#123;&#125;&#125;// BackEndFactory 后端工厂type BackEndFactory struct&#123;&#125;func (f *BackEndFactory) CreateProgrammer() Programmer &#123;    return &amp;BackEndProgrammer&#123;&#125;&#125;func (f *BackEndFactory) CreateArchitect() Architect &#123;    return &amp;BackEndArchitect&#123;&#125;&#125;</code></pre><p>代码比较长，可以对照着类图来看。</p><p>写个场景类（测试）来调用一下：</p><p><strong>abstract_factory/programmer_factory_test.go</strong></p><pre><code class="go">package abstract_factoryimport (    &quot;fmt&quot;    &quot;testing&quot;)func TestCreateProgrammerAndArchitect(t *testing.T) &#123;    fmt.Println(&quot;前端组招到了一个程序员和一个架构师&quot;)    ff := FrontEndFactory&#123;&#125;    fa := ff.CreateArchitect()    fp := ff.CreateProgrammer()    fmt.Println(&quot;前端组接到任务,开始工作...&quot;)    fa.Design()    fp.Work()    fmt.Println(&quot;后端组招到了一个程序员和一个架构师&quot;)    bf := BackEndFactory&#123;&#125;    ba := bf.CreateArchitect()    bp := bf.CreateProgrammer()    fmt.Println(&quot;后端组接到任务,开始工作...&quot;)    ba.Design()    bp.Work()&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestCreateProgrammerAndArchitect前端组招到了一个程序员和一个架构师前端组接到任务,开始工作...前端架构师做了一个页面秒开的设计前端程序员在用WebStorm写TypeScript代码后端组招到了一个程序员和一个架构师后端组接到任务,开始工作...后端架构师做了一个可以抗住上万并发的设计后端程序员在用GoLand写Golang代码--- PASS: TestCreateProgrammerAndArchitect (0.00s)PASS</code></pre><p>看完这个例子之后，是不是彻底明白抽象工厂模式是怎么一回事了呢。</p><p>我们也可以看出，在抽象工厂模式中，添加等级结构很方便——假如我们要添加一个新的等级结构“基础架构（BasicArchitecture）”，那么直接新建对应的程序员类<code>BasicArchitectureProgrammer</code>和架构师类<code>BasicArchitectureArchitect</code>继承<code>Programmer</code>和<code>Architect</code>，再新建一个工厂类<code>BasicArchitectureFactory</code>继承<code>AbstractFactory</code>就可以完成扩展。</p><p>但是，我们也很容易发现添加产品族很难，且违背了开闭原则——假如我们要添加一个新的工种“测试工程师（TestEngineer）”，则需要建立新的抽象类<code>TestEngineer</code>（成员方法可以叫<code>Test()</code>），并且在所有的工厂类里面都添加、实现<code>CreateTestEngineer()</code>用于创建不同等级结构（前端、后端）的测试工程师，这样才可以完成扩展。这种方法显而易见地违背了开闭原则，增大了维护难度，所以在使用抽象工厂模式时最好一开始就把所有的产品族设计好，尽量减少对产品族的添加和删除。</p><h2 id="抽象工厂模式的通用代码"><a href="#抽象工厂模式的通用代码" class="headerlink" title="抽象工厂模式的通用代码"></a>抽象工厂模式的通用代码</h2><p><strong>abstract_factory/abstract_factory.go</strong></p><pre><code class="go">package abstract_factoryimport &quot;fmt&quot;// AbstractProductA 抽象产品类Atype AbstractProductA interface &#123;    DoSomethingA()&#125;// AbstractProductB 抽象产品类Btype AbstractProductB interface &#123;    DoSomethingB()&#125;// ProductA1 产品A1的实现类type ProductA1 struct&#123;&#125;func (p *ProductA1) DoSomethingA() &#123;    fmt.Println(&quot;产品A1的实现方法&quot;)&#125;// ProductA2 产品A2的实现类type ProductA2 struct&#123;&#125;func (p *ProductA2) DoSomethingA() &#123;    fmt.Println(&quot;产品A2的实现方法&quot;)&#125;// ProductB1 产品B1的实现类type ProductB1 struct&#123;&#125;func (p *ProductB1) DoSomethingB() &#123;    fmt.Println(&quot;产品B1的实现方法&quot;)&#125;// ProductB2 产品B2的实现类type ProductB2 struct&#123;&#125;func (p *ProductB2) DoSomethingB() &#123;    fmt.Println(&quot;产品B2的实现方法&quot;)&#125;// AbstractCreator 抽象工厂类type AbstractCreator interface &#123;    CreateProductA() AbstractProductA    CreateProductB() AbstractProductB&#125;// Creator1 产品等级1的工厂实现类type Creator1 struct&#123;&#125;func (c *Creator1) CreateProductA() AbstractProductA &#123;    return &amp;ProductA1&#123;&#125;&#125;func (c *Creator1) CreateProductB() AbstractProductB &#123;    return &amp;ProductB1&#123;&#125;&#125;// Creator2 产品等级2的工厂实现类type Creator2 struct&#123;&#125;func (c *Creator2) CreateProductA() AbstractProductA &#123;    return &amp;ProductA2&#123;&#125;&#125;func (c *Creator2) CreateProductB() AbstractProductB &#123;    return &amp;ProductB2&#123;&#125;&#125;</code></pre><p><strong>abstract_factory/abstract_factory_test.go</strong></p><pre><code class="go">package abstract_factoryimport &quot;testing&quot;func TestAbstractFactory(t *testing.T) &#123;    c1 := Creator1&#123;&#125;    c2 := Creator2&#123;&#125;    a1 := c1.CreateProductA()    a2 := c2.CreateProductA()    b1 := c1.CreateProductB()    b2 := c2.CreateProductB()    a1.DoSomethingA()    a2.DoSomethingA()    b1.DoSomethingB()    b2.DoSomethingB()&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestAbstractFactory产品A1的实现方法产品A2的实现方法产品B1的实现方法产品B2的实现方法--- PASS: TestAbstractFactory (0.00s)PASS</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抽象工厂模式看似很难理解，实际上只要理解了“产品族”和“等级结构”这两个概念，抽象工厂模式就非常简单了。那么它有什么用呢？一个很典型的用途就是适配不同数据库——不同的数据库所提供的操作应该是相同的（增、删、改、查、事务等），但是每种数据库的底层实现又不一样，这时就可以使用抽象工厂模式来生成不同数据库的操作对象；另外，Java的AWT也运用了抽象工厂模式来实现不同操作系统下应用程序界面的统一。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/11/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/11/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="工厂模式的定义"><a href="#工厂模式的定义" class="headerlink" title="工厂模式的定义"></a>工厂模式的定义</h2><p>工厂模式的定义如下：</p><blockquote><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p>——《设计模式之禅》</p></blockquote><p>工厂模式在Go语言中还是很常见的。因为Go语言的结构体没有构造器，而工厂模式本质上就是new一个对象的替代品，所以在项目中一般都需要使用简单工厂模式去实例化一个结构体已达到与构造器相同的目的（即我们经常见到的<code>NewXxx()</code>方法，关于什么是简单工厂模式我们马上就会讲到）；另外在DDD（领域驱动设计）中也经常可以看到工厂模式的身影。</p><h2 id="工厂模式的简单例子"><a href="#工厂模式的简单例子" class="headerlink" title="工厂模式的简单例子"></a>工厂模式的简单例子</h2><p>我们使用Go语言重写《设计模式之禅》中给出的女娲造人的例子：</p><p><strong>factory/human_factory.go</strong></p><pre><code class="go">package factoryimport &quot;fmt&quot;// Human 人类总称type Human interface &#123;    GetColor() // 每个人种的皮肤都有相应的颜色    Talk()     // 人类会说话&#125;// BlackHuman 黑色人种type BlackHuman struct&#123;&#125;func (b *BlackHuman) GetColor() &#123;    fmt.Println(&quot;黑色人种的皮肤颜色是黑色的!&quot;)&#125;func (b *BlackHuman) Talk() &#123;    fmt.Println(&quot;黑人会说话,一般人听不懂.&quot;)&#125;// YellowHuman 黄色人种type YellowHuman struct&#123;&#125;func (y *YellowHuman) GetColor() &#123;    fmt.Println(&quot;黄色人种的皮肤颜色是黄色的!&quot;)&#125;func (y *YellowHuman) Talk() &#123;    fmt.Println(&quot;黄色人种会说话,一般说的都是双字节.&quot;)&#125;// WhiteHuman 白色人种type WhiteHuman struct&#123;&#125;func (w *WhiteHuman) GetColor() &#123;    fmt.Println(&quot;白色人种的皮肤颜色是白色的!&quot;)&#125;func (w *WhiteHuman) Talk()  &#123;    fmt.Println(&quot;白色人种会说话,一般都是单字节.&quot;)&#125;// AbstractHumanFactory 抽象人类创建工厂type AbstractHumanFactory interface &#123;    CreateHuman(t string) Human&#125;// HumanFactory 人类创建工厂type HumanFactory struct &#123;&#125;// CreateHuman 产生一个人种func (h *HumanFactory) CreateHuman(t string) Human &#123;    switch t &#123;    case &quot;b&quot;:        return &amp;BlackHuman&#123;&#125;    case &quot;y&quot;:        return &amp;YellowHuman&#123;&#125;    case &quot;w&quot;:        return &amp;WhiteHuman&#123;&#125;    default:        fmt.Println(&quot;人种生成错误!&quot;)        return nil    &#125;&#125;</code></pre><p><strong>factory/human_factory_test.go</strong></p><pre><code class="go">package factoryimport (    &quot;fmt&quot;    &quot;testing&quot;)func TestHumanFactory_CreateHuman(t *testing.T) &#123;    // 声明阴阳八卦炉    yinYangLu := &amp;HumanFactory&#123;&#125;    // 女娲第一次造人,火候不足,于是白人产生了    fmt.Println(&quot;--造出的第一批人是白色人种--&quot;)    wh := yinYangLu.CreateHuman(&quot;w&quot;)    wh.GetColor()    wh.Talk()    // 女娲第二次造人,火候过足,于是黑人产生了    fmt.Println(&quot;--造出的第二批人是黑色人种--&quot;)    bh := yinYangLu.CreateHuman(&quot;b&quot;)    bh.GetColor()    bh.Talk()    // 第三次造人,火候刚刚好,于是黄色人种产生了    fmt.Println(&quot;--造出的第三批人是黄色人种--&quot;)    yh := yinYangLu.CreateHuman(&quot;y&quot;)    yh.GetColor()    yh.Talk()&#125;</code></pre><p>运行结果如下：</p><pre><code>=== RUN   TestHumanFactory_CreateHuman--造出的第一批人是白色人种--白色人种的皮肤颜色是白色的!白色人种会说话,一般都是单字节.--造出的第二批人是黑色人种--黑色人种的皮肤颜色是黑色的!黑人会说话,一般人听不懂.--造出的第三批人是黄色人种--黄色人种的皮肤颜色是黄色的!黄色人种会说话,一般说的都是双字节.--- PASS: TestHumanFactory_CreateHuman (0.00s)PASS</code></pre><p>与Java版本的代码类似，Go语言版本的代码也非常简单，有过Go语言项目开发经历的话应该不难理解。</p><h2 id="工厂模式的通用代码"><a href="#工厂模式的通用代码" class="headerlink" title="工厂模式的通用代码"></a>工厂模式的通用代码</h2><p><strong>factory/factory.go</strong></p><pre><code class="go">package factoryimport &quot;fmt&quot;// Product 抽象产品类type Product interface &#123;    // Method 抽象方法    Method()&#125;// ConcreteProduct1 具体产品类1type ConcreteProduct1 struct&#123;&#125;func (c *ConcreteProduct1) Method() &#123;    fmt.Println(&quot;我是具体产品类1的业务逻辑&quot;)&#125;// ConcreteProduct2 具体产品类2type ConcreteProduct2 struct&#123;&#125;func (c *ConcreteProduct2) Method() &#123;    fmt.Println(&quot;我是具体产品类2的业务逻辑&quot;)&#125;// Creator 抽象工厂类// 创建一个产品对象,其输入参数类型可以自行设置,这里用了stringtype Creator interface &#123;    CreateProduct(t string) Product&#125;// ConcreteCreator 具体工厂类type ConcreteCreator struct&#123;&#125;func (c *ConcreteCreator) CreateProduct(t string) Product &#123;    switch t &#123;    case &quot;1&quot;:        return &amp;ConcreteProduct1&#123;&#125;    case &quot;2&quot;:        return &amp;ConcreteProduct2&#123;&#125;    default:        // 异常处理        return nil    &#125;&#125;</code></pre><p>实际使用效果如下：</p><p><strong>factory/factory_test.go</strong></p><pre><code class="go">package factoryimport &quot;testing&quot;func TestConcreteCreator_CreateProduct(t *testing.T) &#123;    c := &amp;ConcreteCreator&#123;&#125;    c1 := c.CreateProduct(&quot;1&quot;)    c1.Method()    c2 := c.CreateProduct(&quot;2&quot;)    c2.Method()&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestConcreteCreator_CreateProduct我是具体产品类1的业务逻辑我是具体产品类2的业务逻辑--- PASS: TestConcreteCreator_CreateProduct (0.00s)PASS</code></pre><h2 id="工厂模式的扩展"><a href="#工厂模式的扩展" class="headerlink" title="工厂模式的扩展"></a>工厂模式的扩展</h2><p>除了前面提到的工厂模式之外，工厂模式还有以下扩展：</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>如果只有一个工厂类，就可以将抽象工厂类去掉，只保留实现类，此时我们就可以发现我们没有必要将工厂类实例化，那么我们就将工厂类的方法设置为静态（在Go语言中就是改成不属于任何结构体的函数）。</p><p>这就是简单工厂模式，它是工厂模式的一种弱化，虽然不便于扩展但是很常用，例如我们在项目中用来实例化结构体的<code>NewXxx()</code>函数就是简单工厂模式在Go语言中最简单也最常见应用。</p><p>还是以女娲造人为例，使用简单工厂模式实现的代码如下：</p><p><strong>factory/simple_factory.go</strong></p><pre><code class="go">package factoryimport &quot;fmt&quot;func CreateHuman(t string) Human &#123;    switch t &#123;    case &quot;b&quot;:        return &amp;BlackHuman&#123;&#125;    case &quot;y&quot;:        return &amp;YellowHuman&#123;&#125;    case &quot;w&quot;:        return &amp;WhiteHuman&#123;&#125;    default:        fmt.Println(&quot;人种生成错误!&quot;)        return nil    &#125;&#125;</code></pre><p>对工厂类的改动同时也引起了调用方的改动——不需要将工厂类实例化了，直接调用<code>CreateHuman()</code>即可。</p><p><strong>factory/simple_factory_test.go</strong></p><pre><code class="go">package factoryimport (    &quot;fmt&quot;    &quot;testing&quot;)func TestCreateHuman(t *testing.T) &#123;    // 女娲第一次造人,火候不足,于是白人产生了    fmt.Println(&quot;--造出的第一批人是白色人种--&quot;)    wh := CreateHuman(&quot;w&quot;)    wh.GetColor()    wh.Talk()    // 女娲第二次造人,火候过足,于是黑人产生了    fmt.Println(&quot;--造出的第二批人是黑色人种--&quot;)    bh := CreateHuman(&quot;b&quot;)    bh.GetColor()    bh.Talk()    // 第三次造人,火候刚刚好,于是黄色人种产生了    fmt.Println(&quot;--造出的第三批人是黄色人种--&quot;)    yh := CreateHuman(&quot;y&quot;)    yh.GetColor()    yh.Talk()&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestCreateHuman--造出的第一批人是白色人种--白色人种的皮肤颜色是白色的!白色人种会说话,一般都是单字节.--造出的第二批人是黑色人种--黑色人种的皮肤颜色是黑色的!黑人会说话,一般人听不懂.--造出的第三批人是黄色人种--黄色人种的皮肤颜色是黄色的!黄色人种会说话,一般说的都是双字节.--- PASS: TestCreateHuman (0.00s)PASS</code></pre><h3 id="多工厂类的工厂模式"><a href="#多工厂类的工厂模式" class="headerlink" title="多工厂类的工厂模式"></a>多工厂类的工厂模式</h3><p>随着项目的不断扩展，实例化一个对象可能非常耗费精力，或者工厂类需要实例化很多种不同的对象，这时工厂方法就会变得很长，导致难以阅读。我们可以让工厂类也继承于一个基类，每一个产品类对应一个工厂类，这时工厂类的职责也就变得更加明确了：生产与自己关联的产品。虽然这带来了维护和扩展上的挑战——因为需要同时维护产品类及对应于该产品类的工厂类，但是这样的设计也降低了工厂类的复杂度。</p><p>以女娲造人为例，多个工厂类的工厂模式代码如下：</p><p><strong>factory/multiple_factory.go</strong></p><pre><code class="go">package factoryimport &quot;fmt&quot;// Human1 人类总称type Human1 interface &#123;    GetColor() // 每个人种的皮肤都有相应的颜色    Talk()     // 人类会说话&#125;// BlackHuman1 黑色人种type BlackHuman1 struct&#123;&#125;func (b *BlackHuman1) GetColor() &#123;    fmt.Println(&quot;黑色人种的皮肤颜色是黑色的!&quot;)&#125;func (b *BlackHuman1) Talk() &#123;    fmt.Println(&quot;黑人会说话,一般人听不懂.&quot;)&#125;// YellowHuman1 黄色人种type YellowHuman1 struct&#123;&#125;func (y *YellowHuman1) GetColor() &#123;    fmt.Println(&quot;黄色人种的皮肤颜色是黄色的!&quot;)&#125;func (y *YellowHuman1) Talk() &#123;    fmt.Println(&quot;黄色人种会说话,一般说的都是双字节.&quot;)&#125;// WhiteHuman 白色人种type WhiteHuman1 struct&#123;&#125;func (w *WhiteHuman1) GetColor() &#123;    fmt.Println(&quot;白色人种的皮肤颜色是白色的!&quot;)&#125;func (w *WhiteHuman1) Talk()  &#123;    fmt.Println(&quot;白色人种会说话,一般都是单字节.&quot;)&#125;// AbstractHumanFactory1 抽象人类创建工厂type AbstractHumanFactory1 interface &#123;    // CreateHuman 产生一个人种    // 注意,由于每个子类都有与其自身关联的产品类,所以这里已经不需要通过传递参数来指明创建哪种产品了    CreateHuman() Human&#125;// BlackHumanFactory 黑色人种创建工厂type BlackHumanFactory struct &#123;&#125;// CreateHuman 产生一个黑色人种func (h *BlackHumanFactory) CreateHuman() Human &#123;    return &amp;BlackHuman&#123;&#125;&#125;// YellowHumanFactory 黄色人种创建工厂type YellowHumanFactory struct &#123;&#125;// CreateHuman 产生一个黄色人种func (h *YellowHumanFactory) CreateHuman() Human &#123;    return &amp;YellowHuman&#123;&#125;&#125;// WhiteHumanFactory 白色人种创建工厂type WhiteHumanFactory struct &#123;&#125;// CreateHuman 产生一个白色人种func (h *WhiteHumanFactory) CreateHuman() Human &#123;    return &amp;WhiteHuman&#123;&#125;&#125;</code></pre><p>调用方也需要一定的更改——在实例化每种产品之前先实例化对应的工厂：</p><p><strong>factory/multiple_factory_test.go</strong></p><pre><code class="go">package factoryimport (    &quot;fmt&quot;    &quot;testing&quot;)func TestCreateHuman1(t *testing.T) &#123;    // 女娲第一次造人,火候不足,于是白人产生了    fmt.Println(&quot;--造出的第一批人是白色人种--&quot;)    whf := WhiteHumanFactory&#123;&#125;    wh := whf.CreateHuman()    wh.GetColor()    wh.Talk()    // 女娲第二次造人,火候过足,于是黑人产生了    fmt.Println(&quot;--造出的第二批人是黑色人种--&quot;)    bhf := BlackHumanFactory&#123;&#125;    bh := bhf.CreateHuman()    bh.GetColor()    bh.Talk()    // 第三次造人,火候刚刚好,于是黄色人种产生了    fmt.Println(&quot;--造出的第三批人是黄色人种--&quot;)    yhf := YellowHumanFactory&#123;&#125;    yh := yhf.CreateHuman()    yh.GetColor()    yh.Talk()&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestCreateHuman1--造出的第一批人是白色人种--白色人种的皮肤颜色是白色的!白色人种会说话,一般都是单字节.--造出的第二批人是黑色人种--黑色人种的皮肤颜色是黑色的!黑人会说话,一般人听不懂.--造出的第三批人是黄色人种--黄色人种的皮肤颜色是黄色的!黄色人种会说话,一般说的都是双字节.--- PASS: TestCreateHuman1 (0.00s)PASS</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人认为工厂模式是在Go语言中应用最广泛的一种设计模式——因为Go语言的结构体没有构造器，所以在大型项目中或遇到创建结构体的过程特别复杂的场景时，需要使用简单工厂模式来帮助我们创建结构体。另外，在领域驱动设计（<code>DDD</code>，Domain Driven Design）中，创建聚合根等场景中也用到了工厂模式，尤其是当创建聚合根的逻辑不适合放在聚合根上时。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2021/11/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/11/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h2><p>个人认为单例模式是23种设计模式中最简单也最好理解的一种，定义如下：</p><blockquote><p>Ensure a class has only one instance, and provide a global pointof access to it.</p><p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>——《设计模式之禅》</p></blockquote><p>那它有什么用呢？我目前在项目中遇到的最多的需要使用单例模式情况就是工具类——工具类一般都没有必要用一次就新建一个实例，所以使用单例模式来实现是非常合适的，当然到目前为止我只在Java中遇到过这个场景（毕竟Kotlin有语法层面的支持（object），Golang则很少需要这么做）。还有就是如果创建一个实例需要很大的资源开销（比如建立数据库连接等），那么也可以考虑使用单例模式。</p><h2 id="单例模式的简单例子"><a href="#单例模式的简单例子" class="headerlink" title="单例模式的简单例子"></a>单例模式的简单例子</h2><p>我们使用Go语言重写《设计模式之禅》使用的臣子和皇帝的例子：</p><p><strong>singleton/emperor.go</strong></p><pre><code class="go">package singletonimport &quot;fmt&quot;var instance *emperor // 实例// emperor 皇帝结构体// 这里不导出是因为如果导出(首字母大写),那么在其他包里就可以用e := &amp;Emperor&#123;&#125;来创建新的实例了// 那样就不是单例模式了,我们写这么一堆东西也就没有意义了type emperor struct &#123;&#125;func init() &#123;    // 初始化一个皇帝    instance = &amp;emperor&#123;&#125;&#125;// GetInstance 得到实例func GetInstance() *emperor &#123;    return instance&#125;// Say 皇帝发话了func (e *emperor) Say() &#123;    fmt.Println(&quot;我就是皇帝某某某...&quot;)&#125;</code></pre><p>臣子类改写成了单元测试：</p><p><strong>singleton/emperor_test.go</strong></p><pre><code class="go">package singletonimport (    &quot;testing&quot;)func TestGetInstance(t *testing.T) &#123;    for day := 0; day &lt; 3; day++ &#123;        // 三天见的皇帝都是同一个人,荣幸吧!        e := GetInstance()        e.Say()    &#125;&#125;</code></pre><p>运行结果：</p><pre><code>=== RUN   TestGetInstance我就是皇帝某某某...我就是皇帝某某某...我就是皇帝某某某...--- PASS: TestGetInstance (0.00s)PASS</code></pre><p>简单分析一下这个例子：为什么皇帝是单例的呢？其原因是<code>init()</code>函数仅在包第一次被加载时执行一次，所以只会创建出一个实例，而我们把<code>emperor</code>声明为包外不可访问的了，所以在包的外部无法通过<code>e := &amp;emperor&#123;&#125;</code>或者<code>e := new(emperor)</code>这种方式创建出新的实例，这就实现了自行实例化并且只有一个实例。</p><h2 id="懒汉式与饿汉式"><a href="#懒汉式与饿汉式" class="headerlink" title="懒汉式与饿汉式"></a>懒汉式与饿汉式</h2><p>单例模式的一个常见考点就是“懒汉式”与“饿汉式”。那么在Go语言里如何编写呢？</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>因为饿汉式相对比较好理解一些，代码写起来也更简单，所以我们先讲讲饿汉式。</p><p>顾名思义，饿汉很饿，所以它不等你用到实例就先把实例先给创建好了。这种方法不需要加锁，没有线程安全问题，但是会减慢启动速度，且由于在使用之前就创建了实例，所以会浪费一部分内存空间（也就是说不是“按需创建”）。这种方法适用于创建实例使用的资源比较少的场景。</p><p>实际上，我们刚刚写的皇帝与臣子的代码就是饿汉式写法的一个例子（使用<code>init()</code>函数）。下面给出饿汉式的通用代码：</p><p>写法1：</p><p><strong>singleton/singleton_hungry.go</strong></p><pre><code class="go">package singleton// 饿汉式写法1: 使用全局变量var instance1 = &amp;singleton1&#123;&#125;type singleton1 struct&#123;&#125;func GetInstance1() *singleton1 &#123;    return instance1&#125;// 饿汉式写法2: 使用init函数var instance2 *singleton2type singleton2 struct&#123;&#125;func init() &#123;    instance2 = &amp;singleton2&#123;&#125;&#125;func GetInstance2() *singleton2 &#123;    return instance2&#125;</code></pre><p>需要注意的是两种写法使用起来差不多，因为虽然全局变量的初始化会比<code>init()</code>函数执行早一点，但都是在<code>main()</code>函数之前，所以在使用上没有特别大的差距，具体选择哪种还是要看实际的业务场景。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>有饿汉式自然就会有懒汉式。懒汉式本质上就是按需创建，在你需要用到这个实例的时候才会去创建它。这种方法写起来比较复杂（但也有使用<code>sync.Once</code>的简单写法），可能会产生线程安全问题，适用于创建实例使用的资源较多的场景。</p><p>懒汉式有很多种写法，它们是否线程安全也是不一样的，下面来介绍一下这些写法（注：以下所有代码都在<strong>singleton/singleton_lazy.go</strong>文件中）：</p><h4 id="写法1：不加锁"><a href="#写法1：不加锁" class="headerlink" title="写法1：不加锁"></a>写法1：不加锁</h4><pre><code class="go">// 写法1: 不加锁, 线程不安全var instance3 *singleton3type singleton3 struct&#123;&#125;func GetInstance3() *singleton3 &#123;    if instance3 == nil &#123;        instance3 = &amp;singleton3&#123;&#125;    &#125;    return instance3&#125;</code></pre><p>相信大家都能看出来这种方法是线程不安全的，在并发执行的时候可能会由于多个线程同时判断<code>instance3 == nil</code>成立进而创建多个实例，所以不推荐使用。</p><h4 id="写法2：对GetInstance-方法加锁"><a href="#写法2：对GetInstance-方法加锁" class="headerlink" title="写法2：对GetInstance()方法加锁"></a>写法2：对GetInstance()方法加锁</h4><pre><code class="go">// 写法2: 对GetInstance方法加锁, 线程安全, 但是效率比较低var (    instance4 *singleton4    lock1     sync.Mutex)type singleton4 struct&#123;&#125;func GetInstance4() *singleton4 &#123;    lock1.Lock()    defer lock1.Unlock()    if instance4 == nil &#123;        instance4 = &amp;singleton4&#123;&#125;    &#125;    return instance4&#125;</code></pre><p>由于在多线程并发时<code>GetInstance4()</code>方法只允许一个线程进入，第二个线程需要在第一个线程退出之后才能进入，所以这种方法是线程安全的。但是它也有显而易见的缺点：效率低，因为每次获取实例时都需要加锁解锁。</p><h4 id="写法3：创建单例时加锁"><a href="#写法3：创建单例时加锁" class="headerlink" title="写法3：创建单例时加锁"></a>写法3：创建单例时加锁</h4><pre><code class="go">// 写法3: 创建单例时加锁, 线程不安全, 这种写法仅仅是为了引出写法4var (    instance5 *singleton5    lock2     sync.Mutex)type singleton5 struct&#123;&#125;func GetInstance5() *singleton5 &#123;    if instance5 == nil &#123;        lock2.Lock()        instance5 = &amp;singleton5&#123;&#125;        lock2.Unlock()    &#125;    return instance5&#125;</code></pre><p>这种方法也是线程不安全的。虽然同一时刻只可能有一个线程在执行<code>instance5 = &amp;singleton5&#123;&#125;</code>这行代码，但是仍然有可能有多个线程都判断<code>instance5 == nil</code>成立并创建多个对象。它本质上跟不加锁没什么区别，提及这种写法仅仅是为了引出下面的写法4：双重检查机制。</p><h4 id="写法4：双重检查"><a href="#写法4：双重检查" class="headerlink" title="写法4：双重检查"></a>写法4：双重检查</h4><pre><code class="go">// 写法4: 双重检查, 线程安全var (    instance6 *singleton6    lock3     sync.Mutex)type singleton6 struct&#123;&#125;func GetInstance6() *singleton6 &#123;    if instance6 == nil &#123;        lock3.Lock()        if instance6 == nil &#123;            instance6 = &amp;singleton6&#123;&#125;        &#125;        lock3.Unlock()    &#125;    return instance6&#125;</code></pre><p>这是一种线程安全的写法。既然有可能有多个线程同时判断<code>instance6 == nil</code>，那么再加锁之后再检查一次就行了。但是每一次获取实例都要加锁还要检查两次显然不是一个明智的选择，所以我们有更优的解法：使用<code>sync.Once</code>。</p><h4 id="写法5：使用sync-Once"><a href="#写法5：使用sync-Once" class="headerlink" title="写法5：使用sync.Once"></a>写法5：使用sync.Once</h4><pre><code class="go">// 写法5: 使用sync.Once, 线程安全, 推荐使用var (    instance7 *singleton7    once      sync.Once)type singleton7 struct&#123;&#125;func GetInstance7() *singleton7 &#123;    once.Do(func() &#123;        instance7 = &amp;singleton7&#123;&#125;    &#125;)    return instance7&#125;</code></pre><p><code>sync.Once</code>有点类似于<code>init()</code>函数，它们都执行且仅执行一次，区别在于<code>sync.Once</code>是在你需要的时候执行，而<code>init()</code>是在包第一次被加载的时候执行。那为什么<code>sync.Once</code>可以解决加锁的问题呢？这就跟<code>sync.Once</code>的内部实现有关了。</p><p>以下是<code>sync.Once</code>的源码，非常短，但是很有参考价值：</p><pre><code class="go">type Once struct &#123;    done uint32    m    Mutex&#125;func (o *Once) Do(f func()) &#123;    if atomic.LoadUint32(&amp;o.done) == 0 &#123;        o.doSlow(f)    &#125;&#125;func (o *Once) doSlow(f func()) &#123;    o.m.Lock()    defer o.m.Unlock()    if o.done == 0 &#123;        defer atomic.StoreUint32(&amp;o.done, 1)        f()    &#125;&#125;</code></pre><p>可以发现<code>Do()</code>函数中仅仅做了一次判断——如果传入的函数已经执行了（<code>done</code>的值为1），那么就不执行，直接返回；否则执行<code>doSlow()</code>方法。在<code>doSlow()</code>方法中进行了加锁并执行了传入的函数，在代码块运行结束后再把<code>done</code>修改为1，这样就实现了执行且仅执行一次的功能，并且只有第一次需要加锁，这样对于<code>GetInstance()</code>函数来说就不再需要判断<code>instance</code>是否为<code>nil</code>了，也不再需要手动进行加锁解锁操作了，可谓是非常棒的一种解决方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言实现单例模式还是挺简单的，基本上看一遍就能懂（从Java转到Go的我表示：比的Java简单多了！尤其是sync.Once写法，精彩程度堪比Java单例模式的enum写法），但要注意转变思维——因为Go语言本身的特点，它的单例模式写法与其他语言（Java、C++等）有很大的区别，如果是初学者自然不用在意这个，但是对于有其他语言基础的还是应该注意一下。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzkyNzI1NzM5NQ==&mid=2247484761&idx=2&sn=a6da1f4d9f72db735d7b705b1af839f6&source=41#wechat_redirect">go解锁设计模式之单例模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言：我回来了，我带着23种设计模式回来了</title>
      <link href="/2021/11/22/%E5%89%8D%E8%A8%80%EF%BC%9A%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E5%B8%A6%E7%9D%8023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E6%9D%A5%E4%BA%86/"/>
      <url>/2021/11/22/%E5%89%8D%E8%A8%80%EF%BC%9A%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%88%91%E5%B8%A6%E7%9D%8023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言：我回来了，我带着23种设计模式回来了"><a href="#前言：我回来了，我带着23种设计模式回来了" class="headerlink" title="前言：我回来了，我带着23种设计模式回来了"></a>前言：我回来了，我带着23种设计模式回来了</h1><p>鸽了那么久，我终于回来了！我宣布从今天开始，高产的Martin Jiang又回来了，从今天开始我将努力做到日更，争取每天都能产出一篇高质量的笔记或者文章，直到我找到满意的工作为止。当然，找到工作并不意味着学习这个过程就结束了，只是找到工作之后的事情现在还未可知。</p><p>那么我要填的第一个坑就是鸽了大半年的<strong>Go语言实现23种设计模式</strong>。众所周知，懂得设计模式是每一个有志于从事服务端开发的萌新所必须掌握的知识；并且，设计模式在开发中也是很常用的（例如我之前曾经写过的一篇文章：《使用责任链模式解决多种用户同一个入口登录的问题》）。但是现在虽然市面上讲设计模式的文章、视频、书籍非常多，但是用Go语言描述的却屈指可数，且由于Go语言自身的一些特点，导致很多书中的代码都需要经过大刀阔斧的改造才能运用到Go语言中。那么趁着三刷《设计模式之禅》这个机会，我决定将《设计模式之禅》中的代码使用Go语言重写，对于我在项目中使用过的一些设计模式我也会尝试使用项目中的场景来进行解释，以此达到既学习设计模式，同时又学习Go语言语法与特性的目的。</p><p>话不多说，我们赶紧开始吧。本系列文章的所有代码都将会上传到GitHub，地址：<a href="https://github.com/WenDev/golang-with-design-patterns">WenDev/golang-with-design-patterns</a>，如果对你有帮助的话欢迎帮忙点个Star和Fork，会给我很大很大的鼓励！感谢你的支持~如果在阅读的过程中发现错误或者发现更好的写法欢迎提出Issue或者联系我，我会第一时间进行改正。</p><p>参考资料：</p><ul><li>《设计模式之禅（第2版）》——秦小波</li><li><a href="https://www.bilibili.com/video/BV1GD4y1D7D3">5小时go语言了解设计模式（23个完整）</a></li><li>其余的参考资料会在每篇文章的最后列出。</li></ul><p>以下是一个施工进度表：</p><p>✅：已完成；🚧：施工中；❌：未开始。</p><ul><li>单例模式✅</li><li>工厂模式✅</li><li>抽象工厂模式✅</li><li>模板模式🚧</li><li>建造者模式❌</li><li>代理模式❌</li><li>原型模式❌</li><li>中介者模式❌</li><li>命令模式❌</li><li>责任链模式❌</li><li>装饰模式❌</li><li>策略模式❌</li><li>适配器模式❌</li><li>迭代器模式❌</li><li>组合模式❌</li><li>观察者模式❌</li><li>门面模式❌</li><li>备忘录模式❌</li><li>访问者模式❌</li><li>状态模式❌</li><li>解释器模式❌</li><li>享元模式❌</li><li>桥梁模式❌</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Istio从入门到入土】1. Service Mesh是什么？</title>
      <link href="/2021/11/22/%E3%80%90Istio%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E3%80%911-Service-Mesh%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2021/11/22/%E3%80%90Istio%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E3%80%911-Service-Mesh%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Service-Mesh是什么？"><a href="#Service-Mesh是什么？" class="headerlink" title="Service Mesh是什么？"></a>Service Mesh是什么？</h1><h2 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h2><p>嗯，又给自己挖了个大坑。</p><p>作为一个<code>Cloud Native</code>和<code>Service Mesh</code>爱好者，我一直想为<code>Service Mesh</code>社区做出自己的贡献——但是我开始学习<code>Istio</code>才刚刚一年，并且我仅仅是个大学生，还没有接触过实际上线的微服务，更别说<code>Service Mesh</code>了。我如何才能为我所喜爱的这个社区做出我自己的贡献呢？</p><p>在写这篇文章的晚上，突然想到了自己去年入门<code>Istio</code>时的情景。鉴于很多刚入坑的同学对<code>Istio</code>了解不足，且<code>Istio</code>作为一个大而全的大型微服务管理框架，相比<code>Spring Cloud</code>、<code>Go Micro</code>等微服务开发框架更加难以学习，而且由于<code>Istio</code>在国内还不太火（至少没像<code>Spring Cloud</code>那样火得一塌糊涂），面向零基础同学的教程比较少，而我最近在业余时间也经常学习<code>Istio</code>，所以我打算将自己学习的过程整理成一系列教程，以便像我一样零基础的同学可以快速入门，体会到<code>Istio</code>带给我们的巨大便利。</p><p>这篇文章可能比较学术，主要是讲述什么是<code>Service Mesh</code>、我们为什么需要<code>Service Mesh</code>、为什么选择了<code>Istio</code>等问题。看不懂的话很正常，千万别放弃，要知道我一开始也被这些奇奇怪怪的名词搞得晕头转向，挣扎了一个月、放弃了好几次才真正入门，但当你在这个领域内越走越远，回过头来再看看这些名词，你就会觉得非常简单了。</p><h2 id="Why-Service-Mesh？"><a href="#Why-Service-Mesh？" class="headerlink" title="Why Service Mesh？"></a>Why Service Mesh？</h2><h3 id="传统微服务框架的缺点"><a href="#传统微服务框架的缺点" class="headerlink" title="传统微服务框架的缺点"></a>传统微服务框架的缺点</h3><p>提到<code>微服务(Microservices)</code>，大多数人可能第一反应是<code>Spring Cloud</code>或者是<code>Go Micro</code>，或者是一些其他的微服务框架。这些框架其实仅仅可以称为“微服务开发框架”，我们在学习微服务的时候，都会从这样的微服务开发框架开始学起。这些微服务开发框架看似能为我们解决一切问题，实则不然，如果你读过Martin Fowler和James Lewis的<a href="https://www.martinfowler.com/articles/microservices.html">《Microservices》</a><a href="https://www.martinfowler.com/articles/microservices.html"> </a>，你或许就已经发现它们在某些方面其实严重地违背了微服务定义。那具体来讲，这些框架有什么缺点呢？</p><ol><li><strong>服务治理逻辑与业务代码耦合</strong>。在<code>Spring Cloud</code>等框架中，服务治理逻辑存在于<code>Spring Cloud Alibaba</code>等<code>SDK</code>中，与业务代码紧密耦合；</li><li><strong>服务治理逻辑对业务代码有较强的侵入性</strong>。当承载了服务治理逻辑的<code>SDK</code>发生升级且不向下兼容时，业务代码也必须跟着升级，即使业务逻辑没有发生任何的改变；并且，这些<code>SDK</code>可能相互之间还有版本兼容问题（我就遇到过）；</li><li><strong>组件太多，且质量参差不齐</strong>。各种各样的组件令人眼花缭乱——例如，光是服务注册与发现就有<code>Zookeeper</code>、<code>Nacos</code>、<code>Consul</code>、<code>Eureka</code>等解决方案，并且它们的质量参差不齐，组件之间的代码很难完全复用，学习成本太高，若仅仅是为了实现服务治理就去学习这么多组件，也不是一个很好的选择；</li><li><strong>绑定于同一种语言的技术栈</strong>。微服务的定义中有一条是：“微服务可用不同的语言开发，使用不同的数据存储技术，由不同的团队来管理”，而这些微服务开发框架实际上严重地违反了这一条规则——它们只能用一种语言进行开发，若要接入其它语言则需要手动实现这些框架的服务治理逻辑，加重了开发者的负担；</li><li><strong>无服务调度、资源分配等功能</strong>。微服务架构非常复杂，需要有服务调度、资源分配、流量管理等功能，这些微服务开发框架并没有实现这些功能，而需要借助<code>Kubernetes</code>等平台来实现。但是实际部署时就会发现这些微服务开发框架与<code>Kubernetes</code>等平台在功能上有重合和冲突（例如，两者都实现了服务注册与发现功能），二者很难完美配合。</li></ol><p>并且，在实际开发过程中，我们很容易发现：好像这些传统微服务框架除了屏蔽了一些分布式系统中通信相关的底层逻辑（包括服务注册与发现、远程过程调用、负载均衡、限流熔断等，当然有的框架可能还实现了配置管理等）之外，好像并没有做什么其它的事情。是的，这就是微服务开发框架最大的缺点——它提供的功能实在是太少了，远远不足以支撑一个庞大的微服务系统。</p><h3 id="What-is-Service-Mesh？"><a href="#What-is-Service-Mesh？" class="headerlink" title="What is Service Mesh？"></a>What is Service Mesh？</h3><p>了解了传统的微服务框架的缺点之后，我们很容易就能明白为什么要使用<code>Istio</code>了——<code>Istio</code>完美地解决了传统微服务框架的缺点。由于<code>Istio</code>实际上是一种<code>服务网格（Service Mesh）</code>的实现，而解决这些缺点的实际上是<code>Service Mesh</code>的优点（<code>Istio</code>只是<code>Service Mesh</code>的一种实现，实际上<code>Service Mesh</code>的实现不止这一种，还有<code>NginxMesh</code>和我非常想要学习的<code>Linkerd</code>等），在了解<code>Istio</code>和<code>Service Mesh</code>的优点之前，我们先来看看<code>Service Mesh</code>到底是什么。</p><blockquote><p>由于”Service Mesh”一词的翻译有很多——例如最常见的“服务网格”，还有“服务啮合层”之类的，为了减少误解，本文统一使用”Service Mesh”。</p></blockquote><p><code>Service Mesh</code>一词最早由开发<code>Linkerd</code>的Buoyant公司提出，并于2016年9月29日第一次公开使用了这一术语。Buoyant的CEO——William Morgan对<code>Service Mesh</code>的定义如下：</p><blockquote><p>A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests  through the complex topology of services that comprise a modern, cloud  native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies  that are deployed alongside application code, without the application  needing to be aware.</p></blockquote><p>翻译成中文就是：</p><blockquote><p>Service Mesh是一种专门用于处理服务间通信的基础设施层，它负责在构成现代云原生应用程序的复杂服务拓扑中可靠地传输请求。在实践中，Service Mesh常常被实现为一组与应用程序部署在一起、对应用程序透明的轻量级的网络代理。</p></blockquote><p>从这段话中我们可以知道：</p><ol><li><code>Service Mesh</code>是一种基础设施；</li><li><code>Service Mesh</code>与云原生（<code>Cloud Native</code>，关于Cloud Native我们之后再展开聊聊）应用一起使用；</li><li><code>Service Mesh</code>的功能是传输请求（或者叫“请求分发”）；</li><li><code>Service Mesh</code>与应用程序部署在一起（可以理解为同一个<code>Kubernetes</code> <code>Pod</code>里的两个容器——这是<code>Istio</code>的实现方案；或者是一个应用程序进程和一个<code>Service Mesh</code>相关的进程绑定在一起）；</li><li><code>Service Mesh</code>是对应用程序透明的（即应用程序感知不到<code>Service Mesh</code>的存在，或者说对应用程序零侵入）；</li><li><code>Service Mesh</code>的实现形式是轻量级的网络代理（我们通常把它称为<code>Sidecar</code>）。</li></ol><p>实际上，<code>Service Mesh</code>非常简单，它就是一些与服务绑定在一起的网络代理，还有一些对其进行控制和管理的逻辑。这些代理被称为<code>数据平面/数据面板(Data Plane)</code>，而对其进行管理和控制的逻辑被称为<code>控制平面/控制面板（Control Plane）</code>。数据平面会拦截不同服务之间的请求并对其进行处理（如鉴权、路由、负载均衡等）和转发，并收集一些监控数据以向控制平面汇报；控制平面对数据平面进行控制和协调，例如网络拓扑策略、配置的更新等，还会提供一些方便开发人员和运维人员使用的API。</p><p>在有了<code>Service Mesh</code>之后，服务之间的调用就不会直接通过网络进行了，而是通过网络代理<code>Sidecar</code>进行。当发生服务间调用的时候，虽然从调用方服务本身看起来它是直接调用了被调用方，但是请求实际上是被<code>Sidecar</code>拦截并转发给被调用方了，也可以说是服务调用了<code>Sidecar</code>。<code>Sidecar</code>实际上封装了分布式系统中的各种复杂逻辑，并且对应用程序透明。</p><p>还是不明白？那我画张图：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20210408012102.png"></p><p>图中蓝绿色线可以理解为控制平面与数据平面的交互（如配置下发、数据上报等），而金绿色线可以理解为服务之间的网络请求。是不是一下就明白了呢？</p><p>那为什么它叫<code>Service Mesh</code>呢？如果你只看图中金绿色的部分的话，很容易发现它就像一个网格一样，连接起了各个服务。只不过，实际的<code>Service Mesh</code>肯定比图上这个要复杂许多。</p><p>这里再引用<a href="https://www.servicemesher.com/istio-handbook/concepts/basic.html">Istio Handbook</a>中的一张图，个人认为这张图也非常浅显易懂。这张图中仅仅画出了<code>Service Mesh</code>本身，没有画出<code>Service Mesh</code>中的服务：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20210408012608.png"></p><h3 id="以Istio为代表的Service-Mesh的优点"><a href="#以Istio为代表的Service-Mesh的优点" class="headerlink" title="以Istio为代表的Service Mesh的优点"></a>以Istio为代表的Service Mesh的优点</h3><p>了解了<code>Service Mesh</code>之后，结合前面提到的传统微服务框架的缺点，我们很容易看出<code>Service Mesh</code>的优点：</p><ol><li><strong>服务治理逻辑独立于业务代码</strong>。<code>Service Mesh</code>把绝大多数的服务治理逻辑从业务代码中剥离出来，成为了独立的进程（Sidecar），Sidecar对服务透明，实现了治理逻辑对业务代码的零侵入。实际上不只是代码零侵入，在运行时两者也没有任何的耦合；</li></ol><blockquote><p>实际上这个说法并不严谨。在Service Mesh中，服务本身其实还是需要有很少的一点类似于协议编解码之类的服务治理逻辑的，并且有一些调用链追踪工具（尤其是方法级的调用链追踪）需要在应用程序中手动埋点。对于这两点，我们在之后的实际使用中会有更深的体会。</p><p>但是，Service Mesh产生的这点侵入，相比传统微服务可是少太多了，所以在不严谨的场合下（例如你想安利你被传统微服务折磨的痛苦不堪的同学来用Service Mesh）也可以说“零侵入”。</p></blockquote><ol start="2"><li><strong>真正实现了跨技术栈开发</strong>。由于服务治理逻辑下沉到<code>Service Mesh</code>中，业务代码可以真正实现跨语言开发，不同语言实现的服务可以很方便地通过<code>Service Mesh</code>相互调用，需要的可能仅仅是一个很小的<code>SDK</code>（或者根本就不需要<code>SDK</code>）；</li><li><strong>提供了统一、完整的解决方案</strong>。在同一种<code>Service Mesh</code>的实现产品中，实现各种功能所需的组件基本上是一致的，很少会遇到需要考虑组件选型的问题；</li><li><strong>很方便地实现了服务治理</strong>。由于<code>Service Mesh</code>多了一层<code>Sidecar</code>，所以相比传统微服务它可以很方便地实现灰度发布、蓝绿部署、限流、熔断、故障注入等传统微服务难以实现的服务治理功能。</li></ol><p>实际上，它完美地解决了传统微服务中的大部分缺点。所以在我心中，<code>Service Mesh</code>是目前最棒的架构之一，也是大型微服务应用最终也是最完美的形态。当然，<code>Serverless</code>的出现可能会带来一些变革，但目前还未可知，我们可以一起期待。</p><h3 id="为什么要用Istio？"><a href="#为什么要用Istio？" class="headerlink" title="为什么要用Istio？"></a>为什么要用Istio？</h3><p><code>Service Mesh</code>的优点我们已经了解了，那么为什么选择<code>Istio</code>呢？</p><ol><li><strong>完美兼容Kubernetes</strong>。如果你会使用容器编排工具<code>Kubernetes</code>，那么<code>Istio</code>的入门难度简直就是毛毛雨（虽然进阶和深入的难度还是挺高的，因为抽象的概念比较多），跟着官方文档走，很快就能学会如何使用<code>Istio</code>；</li><li><strong>学习资源丰富</strong>。对于初学者来说，学习资源丰富是一件非常重要的事情。<code>Istio</code>的学习资源非常丰富，并且中文的学习资源也有很多，丰富的学习资源让初学者可以很快地入门；</li><li><strong>方便易用，极大地简化微服务的开发、部署等工作</strong>。有了<code>Istio</code>，我们在开发微服务时就几乎不需要任何微服务框架了，我们可以开心地扔掉<code>Spring Cloud</code>等笨重的微服务开发框架，专注地实现微服务的业务逻辑，而不需要在业务代码中考虑服务治理功能，<code>Istio</code>会帮我们完成这些事；</li><li><strong>服务治理能力强</strong>。根据<code>Service Mesh</code>的定义，<code>Service Mesh</code>本身是没有服务治理逻辑的，但是<code>Istio</code>就提供了强大、易用的服务治理能力。</li></ol><h2 id="Service-Mesh是银弹吗？"><a href="#Service-Mesh是银弹吗？" class="headerlink" title="Service Mesh是银弹吗？"></a>Service Mesh是银弹吗？</h2><p>任何一种架构方式都有其自身的缺点，没有一种架构能适合所有的业务场景，<code>Service Mesh</code>也不例外。虽然<code>Service Mesh</code>相比传统微服务有了很大的进步，被称为“第二代微服务”，但是它也存在以下不足之处：</p><ol><li><strong>复杂</strong>。<code>Service Mesh</code>引入了网络代理<code>Sidecar</code>，而我们知道，组成成分越多的系统就越复杂，每个组件都有出现故障的可能。在本就很复杂的微服务系统中引入<code>Sidecar</code>和其他一些控制逻辑，必然会增加系统的复杂度；并且，在引入了<code>Service Mesh</code>后，我们需要单独学习<code>Service Mesh</code>产品的使用，还需要了解<code>Service Mesh</code>产品中各种组件的功能及其与其他平台的适配与协作，这就要求我们有更强的处理复杂问题的能力；</li><li><strong>延迟高、吞吐量低</strong>。经过<code>Sidecar</code>进行服务间调用必然会显著地增加延迟，也必然会降低应用的吞吐量，虽然这个延迟可能只有几毫秒到几十毫秒，但是在一些对低延迟要求特别高的场景下，这几毫秒的延迟可能就是不可接受的。</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是Service Mesh</a></li><li><a href="https://www.servicemesher.com/istio-handbook/concepts/basic.html">Istio Handbook</a>（强烈推荐对Service Mesh和Istio感兴趣的同学认真地读一读这个网站中的文章，虽然比较学术、有一定的阅读门槛，而且有一定基础（至少得用Istio部署过一个服务吧）之后才能读懂其中的很多内容，但写的实在是太棒了，每次阅读都会有新的感悟。<del>Service Mesher, 永远滴神！Jimmy Song, 永远滴神！啥时候我才能强大到可以加入Service Mesher啊，唉……</del>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务网格 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Istio </tag>
            
            <tag> 服务网格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全面的Kubernetes（K8S）入门笔记</title>
      <link href="/2021/11/22/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84Kubernetes%EF%BC%88K8S%EF%BC%89%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/22/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84Kubernetes%EF%BC%88K8S%EF%BC%89%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="史上最全面的Kubernetes（K8S）入门笔记"><a href="#史上最全面的Kubernetes（K8S）入门笔记" class="headerlink" title="史上最全面的Kubernetes（K8S）入门笔记"></a>史上最全面的Kubernetes（K8S）入门笔记</h1><h2 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h2><p><strong>使用的操作系统为<code>Ubuntu 18.04.4 Server amd64</code>，安装时使用了阿里云镜像源，如果没有使用的话记得换源。</strong></p><p>因为准备虚拟机的过程也比较复杂，所以也记录一下吧。</p><p>创建虚拟机时，创建2核2G的虚拟机，硬盘20G就可以：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044436.png"></p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044510.png"></p><p>我用的是<code>Ubuntu Server 18.04.4</code>，用18.04的话安装过程也是大同小异的：</p><p>选择English：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044633.png"></p><p>Continue Without Updating：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044717.png"></p><p>Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044733.png"></p><p>Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044844.png"></p><p>Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330044916.png"></p><p>输入阿里云的镜像地址：<code>https://mirrors.aliyun.com/ubuntu/</code>，然后Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330045131.png"></p><p>选择<code>Use An Entire Disk And Set Up LVM</code>：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330045227.png"></p><p>选安装位置，咱就一个，没可选的，直接回车。</p><p>选择<code>ubuntu-lv</code>，然后选择<code>edit</code>：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330045659.png"></p><p><code>size</code>改成旁边那个<code>max</code>的数，然后<code>save</code>：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330045811.png"></p><p>然后<code>Done</code>，<code>Continue</code>。</p><p>这里随便写，只需要写一个你能记得住的密码就好：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050030.png"></p><p>按一下回车，然后Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050115.png"></p><p>直接Done：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050151.png"></p><p>然后就可以泡一杯咖啡等安装完成了，这个过程应该不会花费太长时间：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050350.png"></p><p>这样就完成了，Reboot即可。</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050610.png"></p><p>重启之后登录，开始后面的配置。</p><h2 id="Linux基础环境的配置"><a href="#Linux基础环境的配置" class="headerlink" title="Linux基础环境的配置"></a>Linux基础环境的配置</h2><h3 id="使用SSH工具远程连接"><a href="#使用SSH工具远程连接" class="headerlink" title="使用SSH工具远程连接"></a>使用SSH工具远程连接</h3><p><code>ifconfig</code>看一下ip地址，然后用SSH工具登录，因为这个小黑窗口实在是太瞎眼了。SSH工具我用的是<code>Royal TSX</code>，当然直接用终端连接也可以，只是不太方便管理。Windows用户的话可以用<code>XShell</code>或者<code>Final Shell</code>。</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330050809.png"></p><p>成功连接：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330051130.png"></p><p>（强烈建议你们也在SSH工具里用这个JetBrains Mono加粗字体，是真的很舒服，看久了也不会累）</p><p>先更新一下：</p><pre><code class="bash">sudo apt-get update</code></pre><p>应该直接就是最新的。</p><h3 id="设置root用户密码"><a href="#设置root用户密码" class="headerlink" title="设置root用户密码"></a>设置root用户密码</h3><pre><code class="bash">sudo passwd root</code></pre><p>然后写个你能记住的密码就行了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><pre><code class="bash">su # 切换到rootvi /etc/ssh/sshd_config</code></pre><p>33行加上一句：</p><pre><code class="bash">PermitRootLogin yes</code></pre><p>然后重启SSH：</p><pre><code class="bash">service ssh restart</code></pre><p>然后就可以用root用户远程连接了：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200330052008.png"></p><p>这样，我们的Linux环境就准备好了，可以开始进行Kubernetes相关的设置与准备了。</p><h2 id="Kubernetes节点的准备"><a href="#Kubernetes节点的准备" class="headerlink" title="Kubernetes节点的准备"></a>Kubernetes节点的准备</h2><p>注1：本部分参考 <a href="https://www.bilibili.com/video/av62628434?p=102">https://www.bilibili.com/video/av62628434?p=102</a> 进行操作</p><p>注2：以下命令均在<code>root</code>用户下操作。</p><h3 id="安装Kubernetes"><a href="#安装Kubernetes" class="headerlink" title="安装Kubernetes"></a>安装Kubernetes</h3><h4 id="关闭交换空间"><a href="#关闭交换空间" class="headerlink" title="关闭交换空间"></a>关闭交换空间</h4><pre><code class="bash">swapoff -a</code></pre><h4 id="避免开机启动交换空间"><a href="#避免开机启动交换空间" class="headerlink" title="避免开机启动交换空间"></a>避免开机启动交换空间</h4><pre><code class="bash">vi /etc/fstab# 注释掉swap开头的那一行</code></pre><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><pre><code class="bash">ufw disable</code></pre><h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><pre><code class="bash">vi /etc/systemd/resolved.conf# 注释掉DNS开头的那一行，并配置为114.114.114.114</code></pre><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><pre><code class="bash"># 更新软件源apt-get update# 安装依赖apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装docker仓库的gpgcurl -fSSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -# 添加阿里云Docker安装源add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;# 更新软件源apt-get -y update# 安装Dockerapt-get -y install docker-ce# 查看是否安装成功docker version</code></pre><h4 id="配置Docker镜像源"><a href="#配置Docker镜像源" class="headerlink" title="配置Docker镜像源"></a>配置Docker镜像源</h4><pre><code class="bash">vi /etc/docker/daemon.json# 该文件实际上不存在，使用vi编辑时直接新建了</code></pre><p>写入以下内容</p><pre><code class="json">&#123;  &quot;registry-mirrors&quot;: [    &quot;https://registry.docker-cn.com&quot;  ]&#125;</code></pre><p><strong>注意：大家如果有阿里云的镜像加速的话，可以加上去，这样到后面创建容器的时候就会快很多。比如后面安装Calico时，不用阿里云需要二十分钟，用了的话两分钟搞定。比如，这是我的配置：</strong></p><pre><code class="bash">&#123;  &quot;registry-mirrors&quot;: [    &quot;https://yyhz7vyl.mirror.aliyuncs.com&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;http://hub-mirror.c.163.com&quot;  ]&#125;</code></pre><p>重启docker并验证是否配置成功：</p><pre><code class="bash">systemctl restart dockerdocker info</code></pre><p>在靠近末尾的地方有以下输出表示配置成功：</p><pre><code> Registry Mirrors:  https://registry.docker-cn.com/</code></pre><h4 id="安装kubernetes必备的三个工具"><a href="#安装kubernetes必备的三个工具" class="headerlink" title="安装kubernetes必备的三个工具"></a>安装kubernetes必备的三个工具</h4><p>安装阿里云镜像源的证书：</p><pre><code class="bash">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</code></pre><p> 阿里云目前还不支持18.04版本的ubuntu，为了安装kubernetes必备的三个工具，需要先写入镜像源：</p><p>(这些命令请整段复制)</p><pre><code class="bash">cat &lt;&lt; EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF</code></pre><p>安装<code>kubelet</code>、<code>kubeadm</code>、<code>kubectl</code>：</p><pre><code class="bash">apt-get update &amp;&amp; apt-get install -y kubelet kubeadm kubectl</code></pre><p><strong>注意：如果要安装Istio的话，就不可以直接这样安装，因为Istio不支持最新版本的Kubernetes。要安装Istio的话，需要安装1.16.0版本的，可以使用以下命令：</strong></p><pre><code class="bash">apt-get update &amp;&amp; apt-get install -y kubelet=1.16.0-00 kubeadm=1.16.0-00 kubectl=1.16.0-00apt-mark hold kubelet=1.16.0-00 kubeadm=1.16.0-00 kubectl=1.16.0-00</code></pre><h4 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h4><p>首先同步时区：</p><pre><code class="bash">dpkg-reconfigure tzdata</code></pre><p>选择Asia：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200320041414.png"></p><p>选择Shanghai：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200320041500.png"></p><p>然后同步时间：</p><pre><code class="bash"># 安装ntpdateapt-get install ntpdate# 设置系统时间与网络时间同步ntpdate cn.pool.ntp.org# 系统时间写入硬件时间hwclock --systohc</code></pre><h4 id="防止主机名还原"><a href="#防止主机名还原" class="headerlink" title="防止主机名还原"></a>防止主机名还原</h4><pre><code class="bash">vi /etc/cloud/cloud.cfg# 把preserve_hostname: false修改为preserve_hostname: true</code></pre><h3 id="配置主节点和从节点"><a href="#配置主节点和从节点" class="headerlink" title="配置主节点和从节点"></a>配置主节点和从节点</h3><p>我是用的虚拟机部署，所以直接把上面的虚拟机克隆三台出来。</p><h4 id="Kubernetes-Master配置"><a href="#Kubernetes-Master配置" class="headerlink" title="Kubernetes Master配置"></a>Kubernetes Master配置</h4><h5 id="配置静态ip"><a href="#配置静态ip" class="headerlink" title="配置静态ip"></a>配置静态ip</h5><pre><code class="bash">vi /etc/netplan/50-cloud-init.yaml</code></pre><p>粘贴以下内容：</p><pre><code class="yaml">network:   ethernets:    ens33:      addresses: [172.16.103.137/24]      gateway4: 172.16.103.2      nameservers:        addresses: [172.16.103.2]  version: 2</code></pre><p>使配置生效：</p><pre><code class="bash">netplan apply</code></pre><h5 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h5><pre><code class="bash">hostnamectl set-hostname kubernetes-mastercat &gt;&gt; /etc/hosts &lt;&lt; EOF172.16.103.137 kubernetes-masterEOF</code></pre><h4 id="Kubernetes-Node1的配置"><a href="#Kubernetes-Node1的配置" class="headerlink" title="Kubernetes Node1的配置"></a>Kubernetes Node1的配置</h4><h5 id="配置静态ip-1"><a href="#配置静态ip-1" class="headerlink" title="配置静态ip"></a>配置静态ip</h5><pre><code class="bash">vi /etc/netplan/50-cloud-init.yaml</code></pre><p>粘贴以下内容：</p><pre><code class="yaml">network:   ethernets:    ens33:      addresses: [172.16.103.150/24]      gateway4: 172.16.103.2      nameservers:        addresses: [172.16.103.2]  version: 2</code></pre><p>使配置生效：</p><pre><code class="bash">netplan apply</code></pre><h5 id="配置主机名-1"><a href="#配置主机名-1" class="headerlink" title="配置主机名"></a>配置主机名</h5><pre><code class="bash">hostnamectl set-hostname kubernetes-node-01cat &gt;&gt; /etc/hosts &lt;&lt; EOF172.16.103.137 kubernetes-node-01EOF</code></pre><h4 id="Kubernetes-Node2的配置"><a href="#Kubernetes-Node2的配置" class="headerlink" title="Kubernetes Node2的配置"></a>Kubernetes Node2的配置</h4><h5 id="配置静态ip-2"><a href="#配置静态ip-2" class="headerlink" title="配置静态ip"></a>配置静态ip</h5><pre><code class="bash">vi /etc/netplan/50-cloud-init.yaml</code></pre><p>粘贴以下内容：</p><pre><code class="yaml">network:   ethernets:    ens33:      addresses: [172.16.103.151/24]      gateway4: 172.16.103.2      nameservers:        addresses: [172.16.103.2]  version: 2</code></pre><p>使配置生效：</p><pre><code class="bash">netplan apply</code></pre><h5 id="配置主机名-2"><a href="#配置主机名-2" class="headerlink" title="配置主机名"></a>配置主机名</h5><pre><code class="bash">hostnamectl set-hostname kubernetes-node-02cat &gt;&gt; /etc/hosts &lt;&lt; EOF172.16.103.137 kubernetes-node-02EOF</code></pre><h4 id="安装Kubernetes集群"><a href="#安装Kubernetes集群" class="headerlink" title="安装Kubernetes集群"></a>安装Kubernetes集群</h4><h4 id="Kubernetes-Master配置-1"><a href="#Kubernetes-Master配置-1" class="headerlink" title="Kubernetes Master配置"></a>Kubernetes Master配置</h4><h5 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h5><pre><code class="bash"># 创建配置文件存放路径mkdir -p /usr/local/kubernetes/clustercd /usr/local/kubernetes/cluster# 生成配置文件，报错可以不用理会kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml# 编辑配置文件vi kubeadm.yml</code></pre><p>主要改这几个地方：</p><p>1.第12行</p><pre><code class="yaml">  advertiseAddress: 1.2.3.4修改为  advertiseAddress: 172.16.103.137也就是Master节点的地址</code></pre><p>2.第32行</p><pre><code class="yaml">imageRepository: k8s.gcr.io修改为imageRepository: registry.aliyuncs.com/google_containers也就是更换为阿里云的源</code></pre><p>3.36行之后插入：</p><pre><code class="yaml">podSubnet: &quot;10.244.0.0/16&quot;</code></pre><p>也就是：</p><pre><code class="yaml">networking:  dnsDomain: cluster.local  podSubnet: &quot;10.244.0.0/16&quot;  serviceSubnet: 10.96.0.0/12scheduler: &#123;&#125;</code></pre><p>这条设置解决容器之间的通信问题。</p><h5 id="查看所需镜像"><a href="#查看所需镜像" class="headerlink" title="查看所需镜像"></a>查看所需镜像</h5><pre><code class="bash">kubeadm config images list --config kubeadm.yml</code></pre><p>输出应该为：</p><pre><code class="bash">registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.0registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.0registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.0registry.aliyuncs.com/google_containers/kube-proxy:v1.17.0registry.aliyuncs.com/google_containers/pause:3.1registry.aliyuncs.com/google_containers/etcd:3.4.3-0registry.aliyuncs.com/google_containers/coredns:1.6.5</code></pre><p>同样不需要理会报错信息。</p><h5 id="拉取所需镜像"><a href="#拉取所需镜像" class="headerlink" title="拉取所需镜像"></a>拉取所需镜像</h5><pre><code class="bash">kubeadm config images pull --config kubeadm.yml</code></pre><p>输出应该为：</p><pre><code class="bash">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.0[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.0[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.0[config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.17.0[config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.1[config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.4.3-0[config/images] Pulled registry.aliyuncs.com/google_containers/coredns:1.6.5</code></pre><h5 id="安装主节点"><a href="#安装主节点" class="headerlink" title="安装主节点"></a>安装主节点</h5><pre><code class="bash">kubeadm init --config=kubeadm.yml --upload-certs | tee kubeadm-init.log</code></pre><p>时间稍微有点长，完成之后会有以下输出：</p><pre><code class="bash">To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Then you can join any number of worker nodes by running the following on each as root:# 请记住这一句，安装从节点需要使用，而且你的肯定和我这个不一样# 如果忘记了，可以使用 cat kubeadm-init.log 查看kubeadm join 172.16.103.137:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:d572cd0df8924638ec44fea57b6e455cea93ac6ba94cf06bc374b4531fbb3989</code></pre><p>把前两句命令执行一下：</p><pre><code class="bash">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</code></pre><h5 id="Kubernetes-Node-01和Kubernetes-Node-02的配置"><a href="#Kubernetes-Node-01和Kubernetes-Node-02的配置" class="headerlink" title="Kubernetes Node 01和Kubernetes Node 02的配置"></a>Kubernetes Node 01和Kubernetes Node 02的配置</h5><p>只需要执行刚才记住的命令就可以了：</p><pre><code class="bash">kubeadm join 172.16.103.137:6443 --token abcdef.0123456789abcdef \    --discovery-token-ca-cert-hash sha256:d572cd0df8924638ec44fea57b6e455cea93ac6ba94cf06bc374b4531fbb3989</code></pre><p>然后回到<code>Kubenetes Master</code>，使用以下命令查看集群信息：</p><pre><code class="bash">kubectl get nodes</code></pre><p>如果发现两台Node都加入进来了，说明配置成功。</p><h2 id="Kubernetes网络配置"><a href="#Kubernetes网络配置" class="headerlink" title="Kubernetes网络配置"></a>Kubernetes网络配置</h2><p>从上一条命令的输出中集群状态是<code>Not Ready</code>可以知道，集群并没有真正配置完成——因为网络还没有配置，现在三个节点并不能互通。</p><p>在Kubernetes中，<code>kubelet</code>可以在适当的时间调用它找到的插件，为通过kubelet启动的pod进行自动的网络配置。这里选择使用<code>Calico</code>作为Kubernetes的CNI插件进行配置。</p><h3 id="安装Calico"><a href="#安装Calico" class="headerlink" title="安装Calico"></a>安装Calico</h3><pre><code class="bash">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yamlwatch kubectl get pods --all-namespaces # 查看安装状态</code></pre><p>必须要等到状态全部变为<code>running</code>，并且使用<code>kubectl get nodes</code>查看全部变为<code>Ready</code>才算安装成功，时间会比较久，大概十几二十分钟的样子，慢慢来啦。</p><p>等状态全部变为<code>Running</code>，并且<code>kubectl get nodes</code>查看状态全部变为<code>Ready</code>之后，Kubernetes集群就安装成功了。</p><h2 id="测试集群是否可用：安装Nginx"><a href="#测试集群是否可用：安装Nginx" class="headerlink" title="测试集群是否可用：安装Nginx"></a>测试集群是否可用：安装Nginx</h2><p>集群搭建完毕，现在我们试试它可不可以正常使用。</p><p>先安装两个Nginx实例：</p><pre><code class="bash">kubectl run nginx --image=nginx --replicas=2 --port=80</code></pre><p>出现<code>kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</code>可以不用管它。</p><p>这里的<code>--port=80</code>的意思是服务运行在Kubernetes内部的80端口上，并不是映射到外部的端口。至于映射到外部端口，我们下一步再做。</p><p>接下来用<code>kubectl get pods</code>查看集群的状态，还是要等到全部变为<code>Running</code>才算真正成功，但是这次时间会比安装<code>Calico</code>稍微快些，两三分钟就可以搞定。</p><p>然后使用</p><pre><code class="bash">kubectl get deployment</code></pre><p>查看部署的状态：</p><pre><code class="bash">NAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   2/2     2            2           3m47s</code></pre><h3 id="暴露服务的端口"><a href="#暴露服务的端口" class="headerlink" title="暴露服务的端口"></a>暴露服务的端口</h3><pre><code class="bash">kubectl expose deployment nginx --port=80 --type=LoadBalancer</code></pre><p>输出</p><pre><code class="bash">service/nginx exposed</code></pre><p>代表服务暴露成功。</p><p>使用</p><pre><code class="bash">kubectl get services</code></pre><p>可以看到</p><pre><code class="bash">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEkubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP        58mnginx        LoadBalancer   10.96.112.250   &lt;pending&gt;     80:31571/TCP   62s</code></pre><p>注意看<code>PORT(S)</code>里的<code>31571</code>，这是刚刚部署的Nginx暴露出来的端口，如果要访问Nginx，就需要通过这个端口。</p><h3 id="从外部访问服务"><a href="#从外部访问服务" class="headerlink" title="从外部访问服务"></a>从外部访问服务</h3><p>首先查看一下服务的状态：</p><pre><code class="bash">kubectl describe service nginx</code></pre><p>输出：</p><pre><code class="bash">Name:                     nginxNamespace:                defaultLabels:                   run=nginxAnnotations:              &lt;none&gt;Selector:                 run=nginxType:                     LoadBalancerIP:                       10.96.112.250Port:                     &lt;unset&gt;  80/TCPTargetPort:               80/TCPNodePort:                 &lt;unset&gt;  31571/TCPEndpoints:                10.244.140.65:80,10.244.141.193:80Session Affinity:         NoneExternal Traffic Policy:  ClusterEvents:                   &lt;none&gt;</code></pre><p>这里需要使用节点的ip去访问（但是用Master的ip好像也可以？）：</p><pre><code>http://172.16.103.150:31571/http://172.16.103.151:31571/</code></pre><p><strong>注意：别照抄我的地址，因为每个人的都不一样，访问时用一开始安装节点时节点的ip和刚刚得到的端口号去访问。</strong></p><p>如果两个都能看到Nginx的欢迎界面，说明部署成功。</p><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><h4 id="删除已发布的服务"><a href="#删除已发布的服务" class="headerlink" title="删除已发布的服务"></a>删除已发布的服务</h4><pre><code class="bash">kubectl delete deployment nginx</code></pre><p>输出</p><pre><code class="bash">deployment.apps &quot;nginx&quot; deleted</code></pre><p>说明已经删除成功了。</p><h4 id="删除已部署的服务"><a href="#删除已部署的服务" class="headerlink" title="删除已部署的服务"></a>删除已部署的服务</h4><pre><code class="bash">kubectl delete service nginx</code></pre><p>输出</p><pre><code class="bash">service &quot;nginx&quot; deleted</code></pre><p>表示删除成功。</p><h2 id="使用kubectl-create和yaml文件配置服务"><a href="#使用kubectl-create和yaml文件配置服务" class="headerlink" title="使用kubectl create和yaml文件配置服务"></a>使用kubectl create和yaml文件配置服务</h2><p>以前在启动一组容器时，<code>docker-compose</code>是非常方便的，使用一个很简单的yaml文件就可以快速启动一组容器。那kubernetes有没有这样的东西呢？其实是有的，而且还是自带的。那就是<code>kubectl create</code>命令。</p><h3 id="创建yaml文件"><a href="#创建yaml文件" class="headerlink" title="创建yaml文件"></a>创建yaml文件</h3><p>还是以部署Nginx为例。</p><pre><code class="bash">mkdir -p /usr/local/kubernetes/servicecd /usr/local/kubernetes/servicevi nginx.yml</code></pre><p>写入以下内容：</p><pre><code class="yaml"># API版本号apiVersion: apps/v1# 部署类型，如Pod\Deployment\Service\Ingress\ReplicationController等kind: Deployment# 元数据metadata:   # 名称  name: nginx-appspec:  # 部署的实例数量  replicas: 2  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:       # 配置容器，可以配置多个      containers:       # 容器名称      - name: nginx        # 容器镜像，这里必须指定版本号        image: nginx:1.17.9        # 镜像的拉取策略：只有在镜像不存在时才会去拉取        imagePullPolicy: IfNotPresent        # 暴露端口        ports:        # Pod端口        - containerPort: 80---# --- 代表多个配置apiVersion: v1kind: Servicemetadata:   name: nginx-httpspec:   ports:   # Service暴露的80端口  - port: 80    # 上面的80端口映射到容器的80端口    targetPort: 80  type: LoadBalancer  selector:     name: nginx</code></pre><h3 id="根据yaml文件创建服务"><a href="#根据yaml文件创建服务" class="headerlink" title="根据yaml文件创建服务"></a>根据yaml文件创建服务</h3><p>类似于<code>docker-compose</code>，使用Kubernetes创建服务的命令为：</p><pre><code class="bash">kubectl create -f xxx.yml</code></pre><p>输出：</p><pre><code class="bash">deployment.apps/nginx-app createdservice/nginx-http created</code></pre><p>这时候使用<code>kubectl get pods</code>，就可以看到刚才创建好的服务了：</p><pre><code class="bash">NAME                         READY   STATUS    RESTARTS   AGEnginx-app-6654964744-htplj   1/1     Running   0          20snginx-app-6654964744-ll8vn   1/1     Running   0          20s</code></pre><p>使用<code>kubectl get services</code>和<code>kubectl get deployment</code>也可以查看到配置信息：</p><pre><code class="bash">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEkubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP        130mnginx-http   LoadBalancer   10.96.131.188   &lt;pending&gt;     80:31745/TCP   36s</code></pre><pre><code class="bash">NAME        READY   UP-TO-DATE   AVAILABLE   AGEnginx-app   2/2     2            2           93s</code></pre><p>访问</p><pre><code class="bash">http://172.16.103.137:31571/http://172.16.103.150:31571/http://172.16.103.151:31571/</code></pre><p>可以看到Nginx的欢迎页面，说明部署成功。</p><h3 id="停止服务-1"><a href="#停止服务-1" class="headerlink" title="停止服务"></a>停止服务</h3><p>类似于<code>docker-compose down</code>，可以使用</p><pre><code class="bash">kubectl delete -f xxx.yml</code></pre><p>停止一个服务。</p><p>输出：</p><pre><code class="bash">deployment.apps &quot;nginx-app&quot; deletedservice &quot;nginx-http&quot; deleted</code></pre><h2 id="API网关——Ingress"><a href="#API网关——Ingress" class="headerlink" title="API网关——Ingress"></a>API网关——Ingress</h2><p>与微服务架构一样，Kubernetes也需要一个网关，让用户可以从一个统一的入口访问到所有的服务。这个网关就是<code>Ingress</code>。</p><p>Ingress其实有很多实现，这里就用最简单的Nginx来实现了。</p><h4 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h4><pre><code class="bash">mkdir -p /usr/local/kubernetes/ingresscd /usr/local/kubernetes/ingresswget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml</code></pre><p>因为是在GitHub，所以会比较慢，如果实在是连不上，直接从GitHub的地址里拿了之后新建一个<code>mandatory.yml</code>之后再粘贴进去吧：</p><pre><code>https://github.com/kubernetes/ingress-nginx/blob/master/deploy/static/mandatory.yaml</code></pre><p>然后编辑这个文件：</p><pre><code class="bash">vi mandatory.yml</code></pre><p>在215行之后添加：</p><pre><code class="yaml">213       # wait up to five minutes for the drain of connections214       terminationGracePeriodSeconds: 300215       serviceAccountName: nginx-ingress-serviceaccount216       hostNetwork: true  # 新建这一行，表示开启主机网络模式217       nodeSelector:218         kubernetes.io/os: linux</code></pre><h4 id="安装Ingress"><a href="#安装Ingress" class="headerlink" title="安装Ingress"></a>安装Ingress</h4><p>创建Ingress服务：</p><pre><code class="bash">kubectl apply -f mandatory.yml</code></pre><p>使用</p><pre><code class="bash">kubectl get pods -n ingress-nginx -o wide</code></pre><p>查看其状态，仍然是要变为Running之后才算成功。比较慢，大约也需要十分钟左右。</p><pre><code class="bash">NAME                                        READY   STATUS    RESTARTS   AGEnginx-ingress-controller-6ffc8fdf96-bc644   1/1     Running   0          14m</code></pre><h4 id="部署Ingress"><a href="#部署Ingress" class="headerlink" title="部署Ingress"></a>部署Ingress</h4><p>刚才做的仅仅是安装，实际上Ingress虽然安装了，但是并没有部署，我们还需要将它部署上去。</p><pre><code class="bash">vi ingress.yml</code></pre><p>粘贴以下内容：</p><pre><code class="yaml">apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata:   name: nginx-web  annotations:    kubernetes.io/ingress.class: &quot;nginx&quot;    nginx.ingress.kubernetes.io/use-reges: &quot;true&quot;    nginx.ingress.kubernetes.io/proxy-connect-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-send-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-read-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-body-size: &quot;10m&quot;    nginx.ingress.kubernetes.io/rewrite-target: /spec:   rules:   # 这里只能是域名不能是ip  - host: timeline.wendev.site    http:       paths:       - path:         backend:           serviceName: tomcat          servicePort: 8080</code></pre><p>这个配置暂时保存，接下来配置一台tomcat</p><pre><code class="bash">mkdir -p /usr/local/kubernetes/tomcatcd /usr/local/kubernetes/tomcatvi tomcat.yml</code></pre><p>加入以下内容：</p><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: tomcat-app  labels:    app: tomcatspec:  replicas: 2  selector:    matchLabels:      app: tomcat  template:    metadata:      labels:        app: tomcat    spec:      containers:      - name: tomcat        image: tomcat:8.5.43        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: tomcat-httpspec:  type: ClusterIP  ports:    - port: 8080      targetPort: 8080  selector:    app: tomcat</code></pre><p>然后使用<code>kubectl apply -f tomcat.yml</code>创建并部署服务。</p><p>等到全部变为Running状态就可以了，大概需要五六分钟。</p><p>然后就可以部署Ingress了：</p><pre><code class="bash">cd ..cd ingress/kubectl apply -f ingress.yml</code></pre><p>使用</p><pre><code class="bash">kubectl get ingress</code></pre><p>检查Ingress是否启动成功：</p><pre><code>NAME        HOSTS                  ADDRESS   PORTS   AGEnginx-web   timeline.wendev.site             80      2m16s</code></pre><p>这样就说明Ingress启动成功了。</p><h2 id="Kubernetes-Helm"><a href="#Kubernetes-Helm" class="headerlink" title="Kubernetes Helm"></a>Kubernetes Helm</h2><p>Helm是Kubernetes的包管理工具，有点类似于Linux系统中的包管理软件，如<code>apt</code>、<code>pacman</code>等，可以简化Kubernetes的部署、管理工作。</p><h3 id="安装Helm客户端"><a href="#安装Helm客户端" class="headerlink" title="安装Helm客户端"></a>安装Helm客户端</h3><p>从<code>https://github.com/helm/helm/releases</code>下载Helm的安装包，并且上传到服务器上。</p><p>当然，在这里我是直接在服务器上下载的，这样就不用上传了。</p><pre><code class="bash">wget https://get.helm.sh/helm-v3.1.2-linux-amd64.tar.gztar -zxvf helm-v3.1.2-linux-amd64.tar.gzcp linux-amd64/helm /usr/local/bin</code></pre><p>使用<code>helm version</code>检查是否安装成功。</p><p>注意：Helm 3.x已经不需要安装Tiller了，也不需要授权，直接使用就可以了。</p><h2 id="注：Kubernetes常用命令"><a href="#注：Kubernetes常用命令" class="headerlink" title="注：Kubernetes常用命令"></a>注：Kubernetes常用命令</h2><h3 id="检查组件运行状态"><a href="#检查组件运行状态" class="headerlink" title="检查组件运行状态"></a>检查组件运行状态</h3><pre><code class="bash">kubectl get cs</code></pre><p>输出：</p><pre><code class="bash">NAME                 STATUS    MESSAGE             ERRORcontroller-manager   Healthy   okscheduler            Healthy   oketcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;</code></pre><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><pre><code class="bash">kubectl cluster-info</code></pre><p>输出：</p><pre><code class="bash">Kubernetes master is running at https://172.16.103.137:6443KubeDNS is running at https://172.16.103.137:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.</code></pre><h3 id="查看Node节点的状态"><a href="#查看Node节点的状态" class="headerlink" title="查看Node节点的状态"></a>查看Node节点的状态</h3><pre><code class="bash">kubectl get nodes</code></pre><p>输出：</p><pre><code class="bash">NAME                 STATUS   ROLES    AGE   VERSIONkubernetes-master    Ready    master   41m   v1.17.4kubernetes-node-01   Ready    &lt;none&gt;   35m   v1.17.4kubernetes-node-02   Ready    &lt;none&gt;   35m   v1.17.4</code></pre><h3 id="查看pod的状态"><a href="#查看pod的状态" class="headerlink" title="查看pod的状态"></a>查看pod的状态</h3><pre><code class="bash">kubectl get pods</code></pre><p>输出：</p><pre><code class="bash">NAME                     READY   STATUS    RESTARTS   AGEnginx-5578584966-nwtb4   1/1     Running   0          4m58snginx-5578584966-vg6d7   1/1     Running   0          4m58s</code></pre><h3 id="查看已部署的服务"><a href="#查看已部署的服务" class="headerlink" title="查看已部署的服务"></a>查看已部署的服务</h3><pre><code class="bash">kubectl get deployment</code></pre><p>输出：</p><pre><code class="bash">NAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   2/2     2            2           3m47s</code></pre><h3 id="暴露服务端口"><a href="#暴露服务端口" class="headerlink" title="暴露服务端口"></a>暴露服务端口</h3><pre><code class="bash">kubectl expose deployment nginx --port=80 --type=LoadBalancer</code></pre><p>输出：</p><pre><code class="bash">service/nginx exposed</code></pre><h3 id="查看已部署的服务-1"><a href="#查看已部署的服务-1" class="headerlink" title="查看已部署的服务"></a>查看已部署的服务</h3><pre><code class="bash">kubectl get services</code></pre><p>输出：</p><pre><code class="bash">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEkubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP        58mnginx        LoadBalancer   10.96.112.250   &lt;pending&gt;     80:31571/TCP   62s</code></pre><h3 id="查看服务详情"><a href="#查看服务详情" class="headerlink" title="查看服务详情"></a>查看服务详情</h3><pre><code class="bash">kubectl describe service nginx</code></pre><p>输出：</p><pre><code class="bash">Name:                     nginxNamespace:                defaultLabels:                   run=nginxAnnotations:              &lt;none&gt;Selector:                 run=nginxType:                     LoadBalancerIP:                       10.96.112.250       # 这是k8s内部的ipPort:                     &lt;unset&gt;  80/TCPTargetPort:               80/TCPNodePort:                 &lt;unset&gt;  31571/TCP  # 节点的端口Endpoints:                10.244.140.65:80,10.244.141.193:80Session Affinity:         NoneExternal Traffic Policy:  ClusterEvents:                   &lt;none&gt;</code></pre><h3 id="删除已发布的服务-1"><a href="#删除已发布的服务-1" class="headerlink" title="删除已发布的服务"></a>删除已发布的服务</h3><pre><code class="bash">kubectl delete deployment nginx</code></pre><p>输出</p><pre><code class="bash">deployment.apps &quot;nginx&quot; deleted</code></pre><p>说明已经删除成功了。</p><h3 id="删除已部署的服务-1"><a href="#删除已部署的服务-1" class="headerlink" title="删除已部署的服务"></a>删除已部署的服务</h3><pre><code class="bash">kubectl delete service nginx</code></pre><p>输出</p><pre><code class="bash">service &quot;nginx&quot; deleted</code></pre><p>表示删除成功。</p><h2 id="注2：Kubernetes常用概念"><a href="#注2：Kubernetes常用概念" class="headerlink" title="注2：Kubernetes常用概念"></a>注2：Kubernetes常用概念</h2><p>参考 <a href="https://www.bilibili.com/video/av62628434?p=106">https://www.bilibili.com/video/av62628434?p=106</a></p><ul><li><strong>pods</strong> 一组紧密关联的容器集合，他们共享IPC（进程间通信）、网络和UTS命名空间，是Kubernetes调度的基本单位。</li><li><strong>labels</strong> 键值对标签，可以被关联到例如pod这样的对象上去，起到类似于注释的作用</li><li><strong>kube-apiserver</strong> 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册与发现等机制</li><li><strong>kube-scheduler</strong> 负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上</li><li><strong>kube-controller-manager</strong> 负责维护集群的状态，比如故障检测、自动扩展、滚动等新等</li><li><strong>etcd</strong> CentOS基于Raft开发的分布式key/value存储，可用于服务发现、共享配置和一致性保障</li><li><strong>kubelet</strong> 负责维持容器的生命周期，同时也负责Volume和CNI的管理</li><li><strong>runtime</strong> 负责镜像管理以及Pod容器的真正运行</li><li><strong>kube-proxy</strong> 负责为Service提供cluster内部的服务发现和负载均衡</li><li><strong>Master节点</strong> Kubernetes集群主节点，主要由<code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>etcd</code>四个模块组成</li><li><strong>Node节点</strong> Kubernetes集群子节点，主要由<code>kubelet</code>、<code>kube-proxy</code>、<code>runtime</code>三个模块组成</li><li><strong>Kubernetes对象</strong> 主要是<code>Pod</code>、<code>label</code>、<code>Deployment</code>、<code>Service</code>等</li><li><strong>job</strong> Kubernetes内部的临时任务，类似Quartz</li><li><strong>节点</strong> Kubernetes集群中的服务器</li><li><strong>集群</strong> Kubernetes管理的一组服务器集合</li><li><strong>服务</strong> Kubernetes的服务是使用标签选择器标识的一组Pod Service，<strong>除非另有说明，否则服务的虚拟ip只能在集群内访问</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务是万能的吗——我对微服务架构的思考</title>
      <link href="/2021/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84%E5%90%97%E2%80%94%E2%80%94%E6%88%91%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2021/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%B8%87%E8%83%BD%E7%9A%84%E5%90%97%E2%80%94%E2%80%94%E6%88%91%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务是万能的吗——我对微服务架构的思考"><a href="#微服务是万能的吗——我对微服务架构的思考" class="headerlink" title="微服务是万能的吗——我对微服务架构的思考"></a>微服务是万能的吗——我对微服务架构的思考</h1><blockquote><p>几乎所有成功的微服务架构都是从一个巨大的单体应用开始的，并且都是由于单体应用过大而被拆分为微服务架构。</p><p>——《持续演进的Cloud Native：云原生架构下微服务的最佳实践》</p></blockquote><p>作为一个微服务的爱好者，看到有越来越多的企业进行微服务改造，心里当然是感到很高兴的。</p><p>微服务是一种优秀的架构这一点是毋庸置疑的。但是，微服务是万能的吗？微服务真的就是可以解决一切问题的“银弹”吗？</p><h2 id="微服务是什么？"><a href="#微服务是什么？" class="headerlink" title="微服务是什么？"></a>微服务是什么？</h2><p>我们经常说到的“微服务”，绝大多数情况指的都是“微服务架构”。</p><p>那么什么是微服务架构呢？Martin Fowler和James Lewis的<a href="https://www.martinfowler.com/articles/microservices.html">《Microservices》</a>是第一篇详细介绍微服务架构的文章。根据文章我们可以总结出微服务架构的定义和特点如下：</p><ul><li>微服务架构风格是一种将一个单一应用程序开发为一组小型服务（微服务）的方法</li><li>每个微服务运行在自己的进程中，服务间采用轻量级通信机制(通常是HTTP API)来互相通信</li><li>服务围绕业务能力构建，可通过全自动部署机制独立部署</li><li>微服务可用不同的语言开发，使用不同的数据存储技术，由不同的团队来管理</li></ul><p>个人认为，微服务的核心是“组件化”和“解耦”，以及“细粒度的服务拆分”。</p><h2 id="微服务的优点？"><a href="#微服务的优点？" class="headerlink" title="微服务的优点？"></a>微服务的优点？</h2><p>微服务与单体应用相比，具有以下优点：</p><ul><li>微服务的拆分粒度很细，可以更好地聚焦于一个业务或者一项具体的需求</li><li>微服务可以被2～5人的小团队独立开发、独立测试</li><li>服务之间实现了解耦，每个服务都可以独立升级或者被替换</li><li>微服务可以使用不同语言、不同技术栈开发，采用不同的数据存储技术</li></ul><p>那微服务与我们熟知的<code>SOA(Service Oriented Architecture, 面向服务的架构)</code>相比，微服务主要有以下特征和优势：</p><ul><li>没有ESB（企业服务总线）</li><li>去中心化</li><li>强调按业务能力划分</li><li>可以采用不同语言开发</li><li>相比SOA，微服务更加组件化</li></ul><h2 id="为什么微服务不是银弹？"><a href="#为什么微服务不是银弹？" class="headerlink" title="为什么微服务不是银弹？"></a>为什么微服务不是银弹？</h2><p>实际上，虽然微服务看起来非常美好，但是微服务其实并不能解决一切问题，因为微服务存在以下缺点：</p><ol><li>在初期，选择微服务架构的成本非常高：面对一个全新的需求，很难在一开始就对各种需求及业务逻辑有比较清晰的认识。</li><li>并不是所有的场景都适合微服务架构，比如企业的内部系统和逻辑简单的、对移植性要求较高的、轻量级或者对响应时间等性能要求非常高的应用就不适合使用微服务架构，单体架构是这些场景下更合适的选择。</li><li>微服务对自动化工具链、服务治理等基础设施有着比较强的依赖，这些依赖很难在一开始就完全准备好。</li><li>微服务与单体应用相比研发流程的变化非常大，采用微服务架构可能会遇到需要重新组建团队、改变工作流程等问题。</li><li>微服务架构的应用是分布式应用，而分布式系统相比单体应用更加复杂、难以管理，难免会遇到分布式事务、数据一致性、单点故障等问题，同时运维、扩展、调试和故障定位的难度也比单体应用更大。</li><li>由于服务间调用从本地调用变成了远程调用，所以可能会出现响应缓慢、由于网络波动而调用失败等问题，这就需要开发者正确处理局部故障。</li><li>一个微服务系统的组成部分很多，除了上一条提到的服务可能出问题之外，各种框架、中间件都有出现问题的可能，而系统的复杂度越高，定位问题、调试的难度就会越来越大。</li></ol><h2 id="什么样的场景使用微服务架构更好？"><a href="#什么样的场景使用微服务架构更好？" class="headerlink" title="什么样的场景使用微服务架构更好？"></a>什么样的场景使用微服务架构更好？</h2><p>微服务并不能解决一切问题，所以当我们在思考采用何种架构时，对于要不要采用微服务架构，就需要有自己的判断。基于目前掌握的知识，我个人认为以下场景采用微服务架构可能是比较合适的：</p><ol><li><strong>前提：</strong>要采用微服务架构的应用已经稳定或者有明确的形态，并且由于该单体架构的应用过于庞大、笨重或遇到严重的性能瓶颈而考虑拆分；</li><li>研发团队超过50人，日均流量达到千万以上（据了解，单体应用+负载均衡+分库分表+缓存完全可以撑住十几万甚至几十万的日均流量）。并发量比较小时，微服务架构无法体现出它的优势，反而会因为开发、测试、部署太过复杂而显得力不从心。</li><li>需求变化频繁，需要快速迭代、快速交付，过于庞大的单体架构和传统的研发流程难以应对频繁变化的需求时。</li><li>对数据一致性要求不是很高的场景——这可以避免复杂的分布式事务问题。</li><li>某一个业务（如秒杀等）遇到了严重的性能瓶颈，这时再采用单体架构容易造成资源的浪费，可以考虑将其拆分为微服务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Spring Boot+gRPC构建微服务并部署到Istio</title>
      <link href="/2021/11/22/%E4%BD%BF%E7%94%A8Spring-Boot-gRPC%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Istio/"/>
      <url>/2021/11/22/%E4%BD%BF%E7%94%A8Spring-Boot-gRPC%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0Istio/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Spring-Boot-gRPC构建微服务并部署到Istio"><a href="#使用Spring-Boot-gRPC构建微服务并部署到Istio" class="headerlink" title="使用Spring Boot+gRPC构建微服务并部署到Istio"></a>使用Spring Boot+gRPC构建微服务并部署到Istio</h1><p>作为<code>Service Mesh</code>和云原生技术的忠实拥护者，我却一直没有开发过Service Mesh的应用。正好最近受够了Spring Cloud的“折磨”，对Kubernetes也可以熟练使用了，而且网上几乎没有Spring Boot微服务部署到Istio的案例，我就开始考虑用Spring Boot写个微服务的Demo并且部署到Istio。项目本身不复杂，就是发送一个字符串并且返回一个字符串的最简单的Demo。</p><blockquote><p>题外话：我本来是想用Spring MVC写的——因为周围有的同学不相信Spring MVC也可以开发微服务，但是Spring MVC的各种配置和依赖问题把我整的想吐，为了少掉几根头发，还是用了方便好用的Spring Boot。</p></blockquote><p><strong>本项目的所有代码都上传到了GitHub，地址：</strong> <a href="https://github.com/WenDev/spring-boot-istio-demo">https://github.com/WenDev/spring-boot-istio-demo</a> <strong>如果有帮助的话不要吝啬你的Star和Fork呀，如果遇到了问题或者有写得不够好的地方也欢迎提出issue，非常感谢～</strong></p><h2 id="为什么要用Istio？"><a href="#为什么要用Istio？" class="headerlink" title="为什么要用Istio？"></a>为什么要用Istio？</h2><p>目前，对于Java技术栈来说，构建微服务的最佳选择是<code>Spring Boot</code>而Spring Boot一般搭配目前落地案例很多的微服务框架<code>Spring Cloud</code>来使用。</p><p>Spring Cloud看似很完美，但是在实际上手开发后，很容易就会发现Spring Cloud存在以下比较严重的问题：</p><ul><li>服务治理相关的逻辑存在于Spring Cloud Netflix等SDK中，与业务代码紧密耦合。</li><li>SDK对业务代码侵入太大，SDK发生升级且无法向下兼容时，业务代码必须做出改变以适配SDK的升级——即使业务逻辑并没有发生任何变化。</li><li>各种组件令人眼花缭乱，质量也参差不齐，学习成本太高，且组件之间代码很难完全复用，仅仅为了实现治理逻辑而学习SDK也并不是很好的选择。</li><li>绑定于Java技术栈，虽然可以接入其他语言但要手动实现服务治理相关的逻辑，不符合微服务“可以用多种语言进行开发”的原则。</li><li>Spring Cloud仅仅是一个开发框架，没有实现微服务所必须的服务调度、资源分配等功能，这些需求要借助Kubernetes等平台来完成。但Spring Cloud与Kubernetes功能上有重合，且部分功能也存在冲突，二者很难完美配合。</li></ul><p>替代Spring Cloud的选择有没有呢？有！它就是<code>Istio</code>。</p><p>Istio彻底把治理逻辑从业务代码中剥离出来，成为了独立的进程（Sidecar）。部署时两者部署在一起，在一个Pod里共同运行，业务代码完全感知不到Sidecar的存在。这就实现了治理逻辑对业务代码的零侵入——实际上不仅是代码没有侵入，在运行时两者也没有任何的耦合。这使得不同的微服务完全可以使用不同语言、不同技术栈来开发，也不用担心服务治理问题，可以说这是一种很优雅的解决方案了。</p><p>所以，“为什么要使用Istio”这个问题也就迎刃而解了——因为Istio解决了传统微服务诸如业务逻辑与服务治理逻辑耦合、不能很好地实现跨语言等痛点，而且非常容易使用。只要会用Kubernetes，学习Istio的使用一点都不困难。</p><h2 id="为什么要使用gRPC作为通信框架？"><a href="#为什么要使用gRPC作为通信框架？" class="headerlink" title="为什么要使用gRPC作为通信框架？"></a>为什么要使用gRPC作为通信框架？</h2><p>在微服务架构中，服务之间的通信是一个比较大的问题，一般采用RPC或者RESTful API来实现。</p><p>Spring Boot可以使用<code>RestTemplate</code>调用远程服务，但这种方式不直观，代码也比较复杂，进行跨语言通信也是个比较大的问题；而<code>gRPC</code>相比Dubbo等常见的Java RPC框架更加轻量，使用起来也很方便，代码可读性高，并且与Istio和Kubernetes可以很好地进行整合，在Protobuf和HTTP2的加持下性能也还不错，所以这次选择了gRPC来解决Spring Boot微服务间通信的问题。并且，虽然gRPC没有服务发现、负载均衡等能力，但是Istio在这方面就非常强大，两者形成了完美的互补关系。</p><p>由于考虑到各种<code>grpc-spring-boot-starter</code>可能会对Spring Boot与Istio的整合产生不可知的副作用，所以这一次我没有用任何的<code>grpc-spring-boot-starter</code>，而是直接手写了gRPC与Spring Boot的整合。不想借助第三方框架整合gRPC和Spring Boot的可以简单参考一下我的实现。</p><h2 id="编写业务代码"><a href="#编写业务代码" class="headerlink" title="编写业务代码"></a>编写业务代码</h2><p>首先使用<code>Spring Initializr</code>建立父级项目<code>spring-boot-istio</code>，并引入<code>gRPC</code>的依赖。pom文件如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;modules&gt;        &lt;module&gt;spring-boot-istio-api&lt;/module&gt;        &lt;module&gt;spring-boot-istio-server&lt;/module&gt;        &lt;module&gt;spring-boot-istio-client&lt;/module&gt;    &lt;/modules&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;site.wendev&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-istio&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;spring-boot-istio&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot With Istio.&lt;/description&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;io.grpc&lt;/groupId&gt;                &lt;artifactId&gt;grpc-all&lt;/artifactId&gt;                &lt;version&gt;1.28.1&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;</code></pre><p>然后建立公共依赖模块<code>spring-boot-istio-api</code>，pom文件如下，主要就是gRPC的一些依赖：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;spring-boot-istio&lt;/artifactId&gt;        &lt;groupId&gt;site.wendev&lt;/groupId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;spring-boot-istio-api&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.grpc&lt;/groupId&gt;            &lt;artifactId&gt;grpc-all&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.annotation&lt;/groupId&gt;            &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;            &lt;version&gt;1.3.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;extensions&gt;            &lt;extension&gt;                &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;                &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.6.2&lt;/version&gt;            &lt;/extension&gt;        &lt;/extensions&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;0.6.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;protocArtifact&gt;com.google.protobuf:protoc:3.11.3:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;                    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;                    &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.28.1:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;                    &lt;protocExecutable&gt;/Users/jiangwen/tools/protoc-3.11.3/bin/protoc&lt;/protocExecutable&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;goals&gt;                            &lt;goal&gt;compile&lt;/goal&gt;                            &lt;goal&gt;compile-custom&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>建立src/main/proto文件夹，在此文件夹下建立<code>hello.proto</code>，定义服务间的接口如下：</p><pre><code class="protobuf">syntax = &quot;proto3&quot;;option java_package = &quot;site.wendev.spring.boot.istio.api&quot;;option java_outer_classname = &quot;HelloWorldService&quot;;package helloworld;service HelloWorld &#123;    rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;&#125;message HelloRequest &#123;    string name = 1;&#125;message HelloResponse &#123;    string message = 1;&#125;</code></pre><p>很简单，就是发送一个<code>name</code>返回一个带<code>name</code>的<code>message</code>。</p><p>然后生成服务端和客户端的代码，并且放到java文件夹下。这部分内容可以参考gRPC的官方文档。</p><p>有了API模块之后，就可以编写服务提供者（服务端）和服务消费者（客户端）了。这里我们重点看一下如何整合gRPC和Spring Boot。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>业务代码非常简单：</p><pre><code class="java">/** * 服务端业务逻辑实现 * * @author 江文 * @date 2020/4/12 2:49 下午 */@Slf4j@Componentpublic class HelloServiceImpl extends HelloWorldGrpc.HelloWorldImplBase &#123;    @Override    public void sayHello(HelloWorldService.HelloRequest request,                         StreamObserver&lt;HelloWorldService.HelloResponse&gt; responseObserver) &#123;        // 根据请求对象建立响应对象，返回响应信息        HelloWorldService.HelloResponse response = HelloWorldService.HelloResponse                .newBuilder()                .setMessage(String.format(&quot;Hello, %s. This message comes from gRPC.&quot;, request.getName()))                .build();        responseObserver.onNext(response);        responseObserver.onCompleted();        log.info(&quot;Client Message Received：[&#123;&#125;]&quot;, request.getName());    &#125;&#125;</code></pre><p>光有业务代码还不行，我们还需要在应用启动时把gRPC Server也给一起启动起来。首先写一下Server端的启动、关闭等逻辑：</p><pre><code class="java">/** * gRPC Server的配置——启动、关闭等 * 需要使用&lt;code&gt;@Component&lt;/code&gt;注解注册为一个Spring Bean * * @author 江文 * @date 2020/4/12 2:56 下午 */@Slf4j@Componentpublic class GrpcServerConfiguration &#123;    @Autowired    HelloServiceImpl service;    /** 注入配置文件中的端口信息 */    @Value(&quot;$&#123;grpc.server-port&#125;&quot;)    private int port;    private Server server;    public void start() throws IOException &#123;        // 构建服务端        log.info(&quot;Starting gRPC on port &#123;&#125;.&quot;, port);        server = ServerBuilder.forPort(port).addService(service).build().start();        log.info(&quot;gRPC server started, listening on &#123;&#125;.&quot;, port);        // 添加服务端关闭的逻辑        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;            log.info(&quot;Shutting down gRPC server.&quot;);            GrpcServerConfiguration.this.stop();            log.info(&quot;gRPC server shut down successfully.&quot;);        &#125;));    &#125;    private void stop() &#123;        if (server != null) &#123;            // 关闭服务端            server.shutdown();        &#125;    &#125;    public void block() throws InterruptedException &#123;        if (server != null) &#123;            // 服务端启动后直到应用关闭都处于阻塞状态，方便接收请求            server.awaitTermination();        &#125;    &#125;&#125;</code></pre><p>定义好gRPC的启动、停止等逻辑后，就可以使用<code>CommandLineRunner</code>把它加入到Spring Boot的启动中去了：</p><pre><code class="java">/** * 加入gRPC Server的启动、停止等逻辑到Spring Boot的生命周期中 * * @author 江文 * @date 2020/4/12 3:10 下午 */@Componentpublic class GrpcCommandLineRunner implements CommandLineRunner &#123;    @Autowired    GrpcServerConfiguration configuration;    @Override    public void run(String... args) throws Exception &#123;        configuration.start();        configuration.block();    &#125;&#125;</code></pre><p>之所以要把gRPC的逻辑注册成Spring Bean，就是因为在这里要获取到它的实例并进行相应的操作。</p><p>这样，在启动Spring Boot时，由于CommandLineRunner的存在，gRPC服务端也就可以一同启动了。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>业务代码同样非常简单：</p><pre><code class="java">/** * 客户端业务逻辑实现 * * @author 江文 * @date 2020/4/12 3:26 下午 */@RestController@Slf4jpublic class HelloController &#123;    @Autowired    GrpcClientConfiguration configuration;    @GetMapping(&quot;/hello&quot;)    public String hello(@RequestParam(name = &quot;name&quot;, defaultValue = &quot;JiangWen&quot;, required = false) String name) &#123;        // 构建一个请求        HelloWorldService.HelloRequest request = HelloWorldService.HelloRequest                .newBuilder()                .setName(name)                .build();        // 使用stub发送请求至服务端        HelloWorldService.HelloResponse response = configuration.getStub().sayHello(request);        log.info(&quot;Server response received: [&#123;&#125;]&quot;, response.getMessage());        return response.getMessage();    &#125;&#125;</code></pre><p>在启动客户端时，我们需要打开gRPC的客户端，并获取到<code>channel</code>和<code>stub</code>以进行RPC通信，来看看gRPC客户端的实现逻辑：</p><pre><code class="java">/** * gRPC Client的配置——启动、建立channel、获取stub、关闭等 * 需要注册为Spring Bean * * @author 江文 * @date 2020/4/12 3:27 下午 */@Slf4j@Componentpublic class GrpcClientConfiguration &#123;    /** gRPC Server的地址 */    @Value(&quot;$&#123;server-host&#125;&quot;)    private String host;    /** gRPC Server的端口 */    @Value(&quot;$&#123;server-port&#125;&quot;)    private int port;    private ManagedChannel channel;    private HelloWorldGrpc.HelloWorldBlockingStub stub;    public void start() &#123;        // 开启channel        channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();        // 通过channel获取到服务端的stub        stub = HelloWorldGrpc.newBlockingStub(channel);        log.info(&quot;gRPC client started, server address: &#123;&#125;:&#123;&#125;&quot;, host, port);    &#125;    public void shutdown() throws InterruptedException &#123;        // 调用shutdown方法后等待1秒关闭channel        channel.shutdown().awaitTermination(1, TimeUnit.SECONDS);        log.info(&quot;gRPC client shut down successfully.&quot;);    &#125;    public HelloWorldGrpc.HelloWorldBlockingStub getStub() &#123;        return this.stub;    &#125;&#125;</code></pre><p>比服务端要简单一些。</p><p>最后，仍然需要一个CommandLineRunner把这些启动逻辑加入到Spring Boot的启动过程中：</p><pre><code class="java">/** * 加入gRPC Client的启动、停止等逻辑到Spring Boot生命周期中 * * @author 江文 * @date 2020/4/12 3:36 下午 */@Component@Slf4jpublic class GrpcClientCommandLineRunner implements CommandLineRunner &#123;    @Autowired    GrpcClientConfiguration configuration;    @Override    public void run(String... args) &#123;        // 开启gRPC客户端        configuration.start();                // 添加客户端关闭的逻辑        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;            try &#123;                configuration.shutdown();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;));    &#125;&#125;</code></pre><h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><p>业务代码跑通之后，就可以制作Docker镜像，准备部署到Istio中去了。</p><p>在开始编写Dockerfile之前，先改动一下客户端的配置文件：</p><pre><code class="yaml">server:  port: 19090spring:  application:    name: spring-boot-istio-clientserver-host: $&#123;server-host&#125;server-port: $&#123;server-port&#125;</code></pre><p>接下来编写Dockerfile：</p><p>服务端：</p><pre><code class="dockerfile">FROM openjdk:8u121-jdkRUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \  &amp;&amp; echo &#39;Asia/Shanghai&#39; &gt;/etc/timezoneADD /target/spring-boot-istio-server-0.0.1-SNAPSHOT.jar /ENV SERVER_PORT=&quot;18080&quot;ENTRYPOINT java -jar /spring-boot-istio-server-0.0.1-SNAPSHOT.jar</code></pre><p>主要是规定服务端应用的端口为18080，并且在容器启动时让服务端也一起启动。</p><p>客户端：</p><pre><code class="dockerfile">FROM openjdk:8u121-jdkRUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \  &amp;&amp; echo &#39;Asia/Shanghai&#39; &gt;/etc/timezoneADD /target/spring-boot-istio-client-0.0.1-SNAPSHOT.jar /ENV GRPC_SERVER_HOST=&quot;spring-boot-istio-server&quot;ENV GRPC_SERVER_PORT=&quot;18888&quot;ENTRYPOINT java -jar /spring-boot-istio-client-0.0.1-SNAPSHOT.jar \ --server-host=$GRPC_SERVER_HOST \ --server-port=$GRPC_SERVER_PORT </code></pre><p>可以看到这里添加了启动参数，配合前面的配置，当这个镜像部署到Kubernetes集群时，就可以在Kubernetes的配合之下通过服务名找到服务端了。</p><p>同时，服务端和客户端的pom文件中添加：</p><pre><code class="xml">    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;executable&gt;true&lt;/executable&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;com.spotify&lt;/groupId&gt;                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.4.13&lt;/version&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;javax.activation&lt;/groupId&gt;                        &lt;artifactId&gt;activation&lt;/artifactId&gt;                        &lt;version&gt;1.1&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;default&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;build&lt;/goal&gt;                            &lt;goal&gt;push&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;configuration&gt;                    &lt;repository&gt;wendev-docker.pkg.coding.net/develop/docker/$&#123;project.artifactId&#125;                    &lt;/repository&gt;                    &lt;tag&gt;$&#123;project.version&#125;&lt;/tag&gt;                    &lt;buildArgs&gt;                        &lt;JAR_FILE&gt;$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;                    &lt;/buildArgs&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>这样执行<code>mvn clean package</code>时就可以同时把docker镜像构建出来了。</p><h2 id="编写部署文件"><a href="#编写部署文件" class="headerlink" title="编写部署文件"></a>编写部署文件</h2><p>有了镜像之后，就可以写部署文件了：</p><p>服务端：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: spring-boot-istio-serverspec:  type: ClusterIP  ports:    - name: http      port: 18080      targetPort: 18080    - name: grpc      port: 18888      targetPort: 18888  selector:    app: spring-boot-istio-server---apiVersion: apps/v1kind: Deploymentmetadata:  name: spring-boot-istio-serverspec:  replicas: 1  selector:    matchLabels:      app: spring-boot-istio-server  template:    metadata:      labels:        app: spring-boot-istio-server    spec:      containers:        - name: spring-boot-istio-server          image: wendev-docker.pkg.coding.net/develop/docker/spring-boot-istio-server:0.0.1-SNAPSHOT          imagePullPolicy: Always          tty: true          ports:            - name: http              protocol: TCP              containerPort: 18080            - name: grpc              protocol: TCP              containerPort: 18888</code></pre><p>主要是暴露服务端的端口：18080和gRPC Server的端口18888，以便可以从Pod外部访问服务端。</p><p>客户端：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: spring-boot-istio-clientspec:  type: ClusterIP  ports:    - name: http      port: 19090      targetPort: 19090  selector:    app: spring-boot-istio-client---apiVersion: apps/v1kind: Deploymentmetadata:  name: spring-boot-istio-clientspec:  replicas: 1  selector:    matchLabels:      app: spring-boot-istio-client  template:    metadata:      labels:        app: spring-boot-istio-client    spec:      containers:        - name: spring-boot-istio-client          image: wendev-docker.pkg.coding.net/develop/docker/spring-boot-istio-client:0.0.1-SNAPSHOT          imagePullPolicy: Always          tty: true          ports:            - name: http              protocol: TCP              containerPort: 19090</code></pre><p>主要是暴露客户端的端口19090，以便访问客户端并调用服务端。</p><p>如果想先试试把它们部署到k8s可不可以正常访问，可以这样配置Ingress：</p><pre><code class="yaml">apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata:  name: nginx-web  annotations:    kubernetes.io/ingress.class: &quot;nginx&quot;    nginx.ingress.kubernetes.io/use-reges: &quot;true&quot;    nginx.ingress.kubernetes.io/proxy-connect-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-send-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-read-timeout: &quot;600&quot;    nginx.ingress.kubernetes.io/proxy-body-size: &quot;10m&quot;    nginx.ingress.kubernetes.io/rewrite-target: /spec:  rules:    - host: dev.wendev.site      http:        paths:          - path: /            backend:              serviceName: spring-boot-istio-client              servicePort: 19090</code></pre><p>Istio的网关配置文件与k8s不大一样：</p><pre><code class="yaml">apiVersion: networking.istio.io/v1alpha3kind: Gatewaymetadata:  name: spring-boot-istio-gatewayspec:  selector:    istio: ingressgateway  servers:    - port:        number: 80        name: http        protocol: HTTP      hosts:        - &quot;*&quot;---apiVersion: networking.istio.io/v1alpha3kind: VirtualServicemetadata:  name: spring-boot-istiospec:  hosts:    - &quot;*&quot;  gateways:    - spring-boot-istio-gateway  http:    - match:        - uri:            exact: /hello      route:        - destination:            host: spring-boot-istio-client            port:              number: 19090</code></pre><p>主要就是暴露<code>/hello</code>这个路径，并且指定对应的服务和端口。</p><h2 id="部署应用到Istio"><a href="#部署应用到Istio" class="headerlink" title="部署应用到Istio"></a>部署应用到Istio</h2><p>首先搭建k8s集群并且安装istio。我使用的k8s版本是<code>1.16.0</code>，Istio版本是最新的<code>1.6.0-alpha.1</code>，使用<code>istioctl</code>命令安装Istio。建议跑通官方的<code>bookinfo</code>示例之后再来部署本项目。</p><p>注：以下命令都是在开启了自动注入Sidecar的前提下运行的</p><p>我是在虚拟机中运行的k8s，所以<code>istio-ingressgateway</code>没有外部ip：</p><pre><code class="bash">$ kubectl get svc istio-ingressgateway -n istio-systemNAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                                                                                                      AGEistio-ingressgateway   NodePort   10.97.158.232   &lt;none&gt;        15020:30388/TCP,80:31690/TCP,443:31493/TCP,15029:32182/TCP,15030:31724/TCP,15031:30887/TCP,15032:30369/TCP,31400:31122/TCP,15443:31545/TCP   26h</code></pre><p>所以，需要设置IP和端口，以NodePort的方式访问gateway：</p><pre><code class="bash">export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&#39;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#39;)export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&#39;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#39;)export INGRESS_HOST=127.0.0.1export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT</code></pre><p>这样就可以了。</p><p>接下来部署服务：</p><pre><code class="bash">$ kubectl apply -f spring-boot-istio-server.yml$ kubectl apply -f spring-boot-istio-client.yml$ kubectl apply -f istio-gateway.yml</code></pre><p>必须要等到两个pod全部变为Running而且Ready变为2/2才算部署完成。</p><p>接下来就可以通过</p><pre><code class="bash">curl -s http://$&#123;GATEWAY_URL&#125;/hello</code></pre><p>访问到服务了。如果成功返回了<code>Hello, JiangWen. This message comes from gRPC.</code>的结果，没有出错则说明部署完成。</p>]]></content>
      
      
      <categories>
          
          <category> 服务网格 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="/2021/11/22/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2021/11/22/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></p><h2 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h2><p>本题其实也是二分查找的变体。本题与二分查找的不同之处在于找不到待查元素时需要返回插入位置，所以查不到时需要返回<code>l</code>——因为<code>l</code>左边的值一直小于等于<code>target</code>，而<code>r</code>右边的值一直大于等于<code>target</code>，这样退出循环时，因为<code>l</code>左边的值全部小于等于<code>target</code>所以<code>l</code>就是我们要求的插入位置。</p><p>另外这里用了一个小知识点：右移一位相当于除以2，并且比除法运算更快。</p><pre><code class="go">func searchInsert(nums []int, target int) int &#123;    l, r := 0, len(nums)-1    mid := 0    for l &lt;= r &#123;    mid = l + ((r-l)&gt;&gt;1)        if nums[mid] == target &#123;            return mid        &#125; else if nums[mid] &lt; target &#123;            l = mid + 1        &#125; else &#123;            r = mid - 1        &#125;    &#125;    return l&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过76.64%的Golang提交记录）</p><p>内存消耗: <strong>3 MB</strong>（超过14.07%的Golang提交记录）</p><p>时间复杂度：O(logn)，二分查找的时间复杂度为O(logn)；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.回文数</title>
      <link href="/2021/11/22/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2021/11/22/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></p><blockquote><p>转换成字符串并反转、比较字符串（实际上就是转换成rune切片并且比较）的解法因为太简单所以这里就不分享啦，主要来看看怎样不转换成字符串解决这个问题。</p></blockquote><h2 id="解法：反转数字并和原数比较"><a href="#解法：反转数字并和原数比较" class="headerlink" title="解法：反转数字并和原数比较"></a>解法：反转数字并和原数比较</h2><p>首先考虑特殊情况：</p><ol><li>0是回文数，这个不会影响后面的正常解法，因为如果是0的话会直接跳出循环返回true；</li><li>小于0的数字因为前面有个负号，所以肯定不可能是回文数；</li><li>10的倍数都不可能是回文数，因为反转之后0在最高位，这显然是不行的。</li></ol><p>排除这两种情况后我们可以这样做：设置一个变量记录反转后的数字，每次将原数对10取余并给反转数乘10后加到反转数上，最后比较两者是否相同即可。官方题解的反转一半数字是这个解法的变体，效率稍高一些。</p><p>需要注意的是这里不需要像官方题解所说的那样考虑溢出的问题，因为只要是回文数那么反转后的数字一定和原数相等所以肯定不会溢出，若不是回文数导致溢出那就算溢出了也不会对算法的正确性产生影响，因为溢出之后的数字肯定和原数不相等。</p><pre><code class="go">func isPalindrome(x int) bool &#123;    // 小于0的因为有负号所以一定不是回文数    if x &lt; 0 &#123;        return false    &#125;    // 10的倍数都不是回文数,因为最高位不可能是0    if x % 10 == 0 &amp;&amp; x != 0 &#123;        return false    &#125;    // 把数字反转并和原数比较    num := x    rev := 0    for x != 0 &#123;        rev = rev * 10 + x % 10        x /= 10    &#125;    return rev == num&#125;</code></pre><p>执行用时: <strong>20 ms</strong>（超过50%的Golang提交记录）</p><p>内存消耗: <strong>5 MB</strong>（超过55%的Golang提交记录）</p><p>时间复杂度：O(logn)，每次循环都会将原数除以10，所以时间与问题规模呈对数关系；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加</title>
      <link href="/2021/11/22/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2021/11/22/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p><h2 id="解法：模拟加法"><a href="#解法：模拟加法" class="headerlink" title="解法：模拟加法"></a>解法：模拟加法</h2><p>很容易就能看出这题给出的链表长度已经远远超出了go语言中最大整数数值类型<code>uint64</code>所能表示的范围，所以需要对两个链表做模拟加法运算才能得出正确答案。</p><p>在两个链表都没有遍历完时，这个过程就是一个很简单的模拟大数加法而已；其中一个链表遍历完之后，对另一个链表继续使用模拟加法进行计算，当然我们可能还会遇到两个链表都遍历完之后仍有进位没有消除的情况，这时再挂一个1到链表上表示进位即可。这里使用的是带有头结点的链表，所以最后返回答案时需要摘除头结点（即返回<code>head.Next</code>）。</p><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;    p1, p2 := l1, l2    // 头结点,没啥用,只是为了方便创建链表,创建完之后head.Next才是我们要的答案    head := &amp;ListNode&#123;Val: 0, Next: nil&#125;    p := head    c := 0    for p1 != nil &amp;&amp; p2 != nil &#123;        v := p1.Val + p2.Val        // 判断上一位有无进位,如果有,则给这一位的数加1并且清除进位标志        if c == 1 &#123;            v += 1            c = 0        &#125;        // 判断该位置上的两个数相加结果有没有超过10,超过则进位        if v &gt;= 10 &#123;            c = 1        &#125;        // 新建一个链表结点,把这个数存进去,并把结点挂在链表上        node := &amp;ListNode&#123;Val: v % 10, Next: nil&#125;        p.Next = node        // 三个指针往后走一个结点        p = p.Next        p1 = p1.Next        p2 = p2.Next    &#125;    if p1 != nil &#123;        for p3 := p1; p3 != nil; p3 = p3.Next &#123;            v := p3.Val            // 判断上一位有无进位,如果有,则给这一位的数加1并且清除进位标志            if c == 1 &#123;                v += 1                c = 0            &#125;            // 判断该位置上的两个数相加结果有没有超过10,超过则进位            if v &gt;= 10 &#123;                c = 1            &#125;            node := &amp;ListNode&#123;Val: v % 10, Next: nil&#125;            p.Next = node            p = p.Next        &#125;    &#125; else if p2 != nil &#123;        for p4 := p2; p4 != nil; p4 = p4.Next &#123;            v := p4.Val            // 判断上一位有无进位,如果有,则给这一位的数加1并且清除进位标志            if c == 1 &#123;                v += 1                c = 0            &#125;            // 判断该位置上的两个数相加结果有没有超过10,超过则进位            if v &gt;= 10 &#123;                c = 1            &#125;            node := &amp;ListNode&#123;Val: v % 10, Next: nil&#125;            p.Next = node            p = p.Next        &#125;    &#125;    // 看看两个链表遍历完之后还有没有进位,有的话就再挂一个1上去    if c == 1 &#123;        node := &amp;ListNode&#123;Val: 1, Next: nil&#125;        p.Next = node        p = p.Next        c = 0    &#125;    return head.Next&#125;</code></pre><p>执行用时: <strong>16 ms</strong>（超过57%的Golang提交记录）</p><p>内存消耗: <strong>4.6 MB</strong>（超过91%的Golang提交记录）</p><p>时间复杂度：O(max(m, n))，循环的次数取决于两个链表中较长的一个；</p><p>空间复杂度：O(1)，除了返回的链表之外只使用了常数个数的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/2021/11/22/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/11/22/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">1. 两数之和</a></p><h2 id="解法1：暴力枚举（时间换空间）"><a href="#解法1：暴力枚举（时间换空间）" class="headerlink" title="解法1：暴力枚举（时间换空间）"></a>解法1：暴力枚举（时间换空间）</h2><p>估计所有人看到这道题想到的第一个方法都是暴力枚举，即对数组中的每一个数都遍历一次该数组，寻找是否有满足<code>num1 + num2 == target</code>的数。这种方法比较简单，是一种用时间换空间的方法。</p><pre><code class="go">func twoSum(nums []int, target int) []int &#123;    if nums == nil &#123;        return []int&#123;&#125;    &#125;    for index1, num1 := range nums &#123;        for index2, num2 := range nums &#123;            if num1 + num2 == target &amp;&amp; index1 != index2 &#123;                return []int&#123;index1, index2&#125;            &#125;        &#125;                &#125;    return []int&#123;&#125;&#125;</code></pre><p>执行用时: <strong>16 ms</strong>（超过57%的Golang提交记录）</p><p>内存消耗: <strong>4.6 MB</strong>（超过91%的Golang提交记录）</p><p>时间复杂度：O(n^2)，对数组中的每一个数都需要遍历两次数组，所以算法的执行时间与问题规模为平方关系；</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="解法2：哈希表（空间换时间）"><a href="#解法2：哈希表（空间换时间）" class="headerlink" title="解法2：哈希表（空间换时间）"></a>解法2：哈希表（空间换时间）</h2><p>除了暴力枚举之外，还有一种不太好想到的方法：用空间换时间。我们可以边遍历数组边将数组元素<code>num</code>作为key、<code>num</code>的下标作为value放入哈希表中，如果在之后的遍历中遇到<code>target - num</code>在哈希表中的情况，说明找到了满足要求的数，直接返回遍历到的数据的下标和该key对应的value即可。注意要先比较再插入哈希表，以此避免<code>num</code>和自身比较。</p><pre><code class="go">func twoSum(nums []int, target int) []int &#123;    if nums == nil &#123;        return []int&#123;&#125;    &#125;    t := make(map[int]int)    for index, num := range nums &#123;        if i, ok := t[target-num]; ok &#123;            return []int&#123;i, index&#125;        &#125;        t[num] = index    &#125;    return []int&#123;&#125;&#125;</code></pre><p>执行用时: <strong>4 ms</strong>（超过98%的Golang提交记录）</p><p>内存消耗: <strong>4.2 MB</strong>（超过35%的Golang提交记录）</p><p>时间复杂度：O(n)，只需要遍历一次数组；</p><p>空间复杂度：O(n)，哈希表的长度与问题规模成正比。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给想学Markdown的你的一个简单的Markdown语法教程</title>
      <link href="/2021/11/22/%E7%BB%99%E6%83%B3%E5%AD%A6Markdown%E7%9A%84%E4%BD%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/"/>
      <url>/2021/11/22/%E7%BB%99%E6%83%B3%E5%AD%A6Markdown%E7%9A%84%E4%BD%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="给想学Markdown的你的一个简单的Markdown语法教程"><a href="#给想学Markdown的你的一个简单的Markdown语法教程" class="headerlink" title="给想学Markdown的你的一个简单的Markdown语法教程"></a>给想学Markdown的你的一个简单的Markdown语法教程</h1><blockquote><p>这篇文章是对我所知道的常用、兼容性较好的Markdown语法的一个简单的总结，文中所有的语法在Typora编辑器和简书上都可以正确显示，如有错漏之处，烦请指正。</p></blockquote><h2 id="什么是Markdown？"><a href="#什么是Markdown？" class="headerlink" title="什么是Markdown？"></a>什么是Markdown？</h2><p>我觉得对HTML比较熟悉的同学可能会很容易地回答出这个问题——Markdown其实就是一个轻量级、用来编写文档的更易用的HTML。</p><p>当然，对于没有基础的同学，可以暂时这么认为：Markdown是一门标记语言，可以算是简化版的Word，但是你不需要为了设置各种格式而用鼠标点来点去了，一切格式的控制都像HTML一样，用代码就可以完成。</p><p>Markdown文件的扩展名是<code>.md</code>，建文件的时候不要建错了。</p><p><strong>注意：Markdown的各种符号都是英文符，尤其要注意圆括号也是英文的圆括号。</strong></p><h2 id="Markdown编辑器推荐"><a href="#Markdown编辑器推荐" class="headerlink" title="Markdown编辑器推荐"></a>Markdown编辑器推荐</h2><p>在开始学习之前，肯定需要一份趁手的工具。</p><p>Markdown最好用专门编辑Markdown的编辑器来写。这里推荐几个我比较喜欢的Markdown编辑器，在学习Markdown语法之前可以先了解一下它们：</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>说到Markdown编辑器，肯定首推Typora了，用过的人都知道它有多好用，而且还支持写HTML，而且颜值非常高，还支持换主题。我这篇教程就是使用Typora写出来的。</p><p>Typora跟绝大多数左边编辑右边预览的Markdown编辑器都不同，是<strong>实时全屏预览</strong>的——你打完之后，立马就可以看到效果，看起来跟Word一样，却比Word简洁的多。如果不满意，也可以进源代码模式再去改，当然有些格式也是可以直接改的。</p><p>Typora还带大纲功能，真的是十分方便，我用过的Markdown编辑器里除了带目录插件的VSCode和语雀之外还没见过有哪个可以实时生成大纲的。</p><p><strong>最重要的是：Typora是跨平台的！跨平台！跨平台！跨平台！重要的事情说三遍！带Linux玩的都是好朋友！</strong></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>没错，大名鼎鼎的VSCode也是可以写Markdown的（好像没有VSCode做不到的事情），而且语法高亮还挺完备的，相关插件也有很多。个人感觉使用体验仅次于Typora。</p><p>推荐装一个<code>Markdown Preview Enhanced</code>插件，这样就可以实时预览了，还有个神器<code>Markdown All in One</code>也很好用，但是需要额外记一些快捷键。强烈建议装一个<code>markdownlint</code>做语法规范检查，毕竟Markdown的编码规范还是挺重要的。</p><p>使用体验上，除了不是实时全屏预览以外，使用体验跟Typora几乎没什么差别，就是VSCode的使用体验。</p><p><strong>最重要的是：VSCode也是跨平台的！跨平台！跨平台！跨平台！重要的事情说三遍！带Linux玩的都是好朋友！</strong></p><h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p>了解我的人应该都知道我在简书上写了多少东西。客观来说，作为在线的编辑器，虽然没有语法高亮，但是简书还是挺不错的，容错能力很强（比如标题的#号后面不打空格、段内换行不打空格这种不规范的写法都能正确识别），实时预览也做得很不错。很多时候有些比较短的文章我不想在本地开Typora写，就直接在简书上写了，还是挺舒服的。</p><p>最主要的还是简书自带图床，不用为把图片保存在哪里而发愁。</p><p>另外，简书的广告比CSDN少多了，界面也是我喜欢的风格，这也是我推荐它而不是CSDN的原因。</p><p>简书也支持富文本。</p><p><strong>当然，简书也是跨平台的！毕竟Web应用从来都不会受平台限制，只要有浏览器就能访问。</strong></p><h3 id="Md2All"><a href="#Md2All" class="headerlink" title="Md2All"></a>Md2All</h3><p>官网：<a href="http://md.aclickall.com/">http://md.aclickall.com/</a></p><p>这个东西比较冷门，本来的作用是将Markdown格式转换为富文本，但是单纯用来编辑Markdown也是挺不错的，如果你对CSS比较熟悉的话，你还可以把它生成的富文本变得非常漂亮。</p><p>不支持云同步，写完之后记得保存到本地。</p><p>最大的缺点就是不带语法高亮了。坦白来说，写Markdown没语法高亮是真的难受。</p><h3 id="印象笔记-为知笔记"><a href="#印象笔记-为知笔记" class="headerlink" title="印象笔记/为知笔记"></a>印象笔记/为知笔记</h3><p>说到有云同步功能的，除了本来就是Web应用、自带云同步的简书就是这两个了吧。这两个作为笔记类的软件，也是很出名的。</p><p>虽然印象笔记是最近才有的Markdown功能，但是语法高亮还是挺不错的，比为知笔记舒服一些，也可以实时预览，我发在简书上那篇Maven学习笔记就是用印象笔记写的。为知笔记不是很推荐，没高亮也没实时预览。</p><p>但是印象笔记那个Markdown。。。也是有够难受的，支持很有限，而且……真的太丑了，比不上Typora不说，毕竟人家太无敌了，但是连VSCode甚至Markdown Pad都比不上，就有点说不过去了……</p><p>总之这俩不建议用，想要云同步的话直接用简书就行了，还顺便开通了个个人博客。当然你也可以“曲线救国”，用坚果云、iCloud、OneDrive做云同步。比较邪门的玩法还可以在GitHub上建一个仓库存你的笔记（论GitHub的<del>错误</del>正确用法）。</p><p><strong>想看正经推荐的到这里就可以往下翻去看教程了，以下几个都是不正经推荐。</strong></p><h3 id="Markdown-Pad"><a href="#Markdown-Pad" class="headerlink" title="Markdown Pad"></a>Markdown Pad</h3><p>Windows独享。</p><p>我18年入门Markdown的时候使用的第一个编辑器，可以说是麻雀虽小五脏俱全吧，比较简陋，但是功能还是比较完善的。</p><p>一个很大的亮点就是自带图床了，对图片很友好，毕竟Markdown最大的短板应该就是图片了。</p><p>可以试试，但是不推荐日常使用。</p><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p>macOS独享。</p><p><del>这是你没见过的船新玩法。</del></p><p>一开始我以为这么玩的都是大佬，但是macOS默认打开Markdown文件的方式居然真的是Xcode，真是无力吐槽了。。。</p><p>不过客观上来讲，除了没实时预览，Xcode写Markdown感觉还是挺不错的，毕竟语法高亮比较完备，颜值也是真的高。虽然本身是个跟Visual Studio一样的超重量级的IDE，但是平常使用的话还是感觉不大到。</p><p><del>真的会有人日常用这玩意写Markdown吗……</del></p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>macOS/Linux独享，Windows有移植版本不过巨难用。</p><p><del>这是你没见过的船新玩法*2。</del></p><p>嗯，不用多说，玩Vim的都是大佬。</p><p>反正我玩不动，各种命令和快捷键都快记疯了，也就写代码的时候开个Vim模拟器玩玩了。</p><p>但是有一说一，Vim带语法高亮，确实可以写Markdown。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown一共支持六级标题，与HTML的<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>作用相同。</p><p>写法：是第几级标题就在前面写几个<code>#</code>，<code>#</code>后面打一个空格，然后再跟上标题内容。</p><p>一级标题还有一种比较冷门的写法，就是在标题行的下一行打<code>-</code>，几个都可以。Typora需要进入源代码模式才能打出。因为实在太麻烦了，所以这种写法不建议大家用，用刚才说的<code>#</code>就可以了。</p><p>不打空格的话大多数编辑器识别不了，但也有能识别的，比如简书和Markdown Pad，Typora老版本好像也可以。但是出于标准、规范而言，大家还是应该打一个空格。</p><p>注意：标题前后都应该有一个空行。</p><p>例如：</p><pre><code class="markdown"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>注意：有的编辑器只支持四级标题（例如语雀），所以建议大家最好不要使用超过四级标题。</p><p>注意2：严格意义上，一篇Markdown只可以有一个一级标题，但是看了许多人的Markdown，遵守这个规定的人实在是不多啊～<del>（反正我也不遵守）</del></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Markdown的正文与HTML的<code>&lt;p&gt;</code>标签类似。但是在Markdown里不用任何标识符，直接写就是一个段落。</p><p>注意：严格意义上讲，Markdown直接打一个回车并不是换行。它的换行方式有两种：</p><h3 id="换段落"><a href="#换段落" class="headerlink" title="换段落"></a>换段落</h3><p>两个段落之间空出一行，就相当于另起一段。</p><p>Markdown：</p><pre><code class="mark">this is a paragraphthis is another paragraph</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;p&gt;  this is a paragraph&lt;/p&gt;&lt;p&gt;  this is another paragraph&lt;/p&gt;</code></pre><p>效果：</p><p>this is a paragraph</p><p>this is another paragraph</p><p>注意：有的Markdown编辑器按回车默认换段落，例如Typora，有的就不会，例如简书（一个回车默认识别为段内换行）。</p><p>注意2:Markdown里打多少个回车都只识别为一个，所以打一个就够了。</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>段落内换行的方式是一行后接两个（有的编辑器好像需要四个）空格，再接一个回车。</p><p>这两个空格加一个回车的作用相当于HTML的<code>&lt;br&gt;</code>标签。</p><p>但是有的编辑器，只打一个回车也能被识别为段内换行，比如Typora（需要在源代码模式下）和简书。</p><p>例如：</p><pre><code class="markdown">this is a line  this is another line</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;p&gt;  this is a line&lt;br&gt;this is another line&lt;/p&gt;</code></pre><p>效果：</p><p>this is a line<br>this is another line</p><p>注意：</p><p>目前绝大多数的编辑器都支持把单独一个回车视为段内换行，例如简书和Typora（需要进入源代码模式）。不过大家还是应该在需要段内换行的时候在行的末尾打至少两个空格。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Markdown的引用是非常简单的，只要在引用行的开头打一个<code>&gt;</code>，再跟一个空格，这一行就变成引用了。</p><p>相当于HTML的<code>&lt;blockquote&gt;</code>标签。</p><p>例如：</p><pre><code class="markdown">&gt; 这是一段引用</code></pre><p>相当于HTML：</p><pre><code class="HTML">&lt;blockquote&gt;这是一段引用&lt;/blockquote&gt;</code></pre><p>效果：</p><blockquote><p>这是一段引用</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>注意：按照规范，列表与段落、标题之间应该空一行。</p><p>注意2：列表项之间不需要多空一行，也不需要在列表项的末尾打空格换行。列表项的每一项是自动独立成一行的。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表的写法很简单，跟Word一样，就是数字加上一个英文的<code>.</code>，再接一个空格。</p><p>相当于HTML的<code>&lt;ol&gt;</code>+<code>&lt;li&gt;</code>。</p><p>例如：</p><pre><code class="markdown">1. first2. second</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;ol&gt;  &lt;li&gt;first&lt;/li&gt;  &lt;li&gt;second&lt;/li&gt;&lt;/ol&gt;</code></pre><p>效果：</p><ol><li>first</li><li>second</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>Markdown的无序列表打法不止一种，这里只介绍最常用的两种：<code>-</code>后跟一个空格或者<code>+</code>后跟一个空格。两者可以混用，我一般用<code>+</code>加一个空格的打法。</p><p>相当于HTML的<code>&lt;ul&gt;</code>+<code>&lt;li&gt;</code>。</p><p>例如：</p><pre><code class="markdown">- 123+ 123</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;123&lt;/li&gt;  &lt;li&gt;123&lt;/li&gt;&lt;/ul&gt;</code></pre><p>效果：</p><ul><li>123</li></ul><ul><li>123</li></ul><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表的打法相对复杂些，是<code>- [ ]</code>后跟一个空格。注意在Typora等实时预览的编辑器里，打出的顺序是：</p><ol><li>先打出<code>-[]</code>（方括号中间和减号后面无空格），然后后面打一个空格</li><li>方括号中间加一个空格</li><li>减号与左方括号之间加一个空格</li></ol><p>打钩的任务列表的方括号中间是一个<code>x</code>，就是小写的x，没有空格。</p><p>相当于HTML<code>&lt;form&gt;</code>里的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，打钩的就是有<code>checked</code>属性的。</p><p>例如：</p><pre><code class="markdown">- [ ] 未完成- [x] 已完成</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;form&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot;&gt;  &lt;label for=&quot;checkbox&quot;&gt;未完成&lt;/label&gt;  &lt;br&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;checkbox_checked&quot; checked&gt;  &lt;label for=&quot;checkbox_checked&quot;&gt;已完成&lt;/label&gt;&lt;/form&gt;</code></pre><p>效果：</p><ul><li><input disabled="" type="checkbox"> 未完成</li><li><input checked="" disabled="" type="checkbox"> 已完成</li></ul><p>注意：有的编辑器在打有序列表和无序列表时不跟空格也可以识别，比如简书和Markdown Pad，但是绝大多数都是无法识别的，所以建议大家按照标准，在数字和符号后面跟一个空格。</p><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>非常简单，用<code>**</code>包裹要加粗的内容就可以了。</p><p>相当于HTML的<code>&lt;strong&gt;</code>。</p><p>例如：</p><pre><code class="markdown">在Java中，被标识为final的类**不能被继承**。</code></pre><p>相当于HTML：</p><pre><code class="html">在Java中，被标识为final的类&lt;srong&gt;不能被继承&lt;/strong&gt;。</code></pre><p>效果：</p><p>在Java中，被标识为final的类<strong>不能被继承</strong>。</p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>与加粗打法很像，只不过斜体是打一个<code>*</code>而加粗是两个。</p><p>相当于HTML的<code>&lt;i&gt;</code>。</p><p>例如：</p><pre><code class="markdown">*我是斜的*</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;i&gt;我是斜的&lt;/i&gt;</code></pre><p>效果：</p><p><em>我是斜的</em></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>删除线的打法也非常简单，使用两个<code>~</code>包裹要画删除线的部分就可以了。</p><p>相当于HTML的<code>&lt;strike&gt;</code>。</p><p>例如：</p><pre><code class="markdown">~~看完这篇文章说不定你就可以入门HTML了~~</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;strike&gt;看完这篇文章说不定你就可以入门HTML了&lt;/strike&gt;</code></pre><p>效果：</p><p><del>看完这篇文章说不定你就可以入门HTML了</del></p><h2 id="行内代码-专有名词"><a href="#行内代码-专有名词" class="headerlink" title="行内代码/专有名词"></a>行内代码/专有名词</h2><p>这个名字是我自己起的，因为我实在不知道它叫啥。。。</p><p>这个东西一般用来标记专有名词，或者一些简单的代码。</p><p>打法很简单，就是用两个`（就是Esc键下面，跟~在一起的那个，在英文下直接按就可以打出这个了。这个符号的名字其实叫“反引号”）把要标记的部分包裹起来就行了。</p><p>相当于HTML的<code>&lt;code&gt;</code>。</p><p>例如：</p><pre><code class="mark">`Java`是世界上最好的语言</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;code&gt;Java&lt;/code&gt;是世界上最好的语言</code></pre><p>效果：</p><p><code>Java</code>是世界上最好的语言</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块也有两种打法，各有各的优缺点。</p><p>注意：代码块前后都要与段落之间有一个空行。</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>第一种打法是三个`（就是刚才打行内代码时用到的那个，三个~也是可以的）加上你代码的语言名称，然后在代码结束的地方再打三个。这也是我最常用的打法。</p><p>相当于HTML的<code>&lt;pre&gt;</code>。</p><p>例如：</p><pre><code class="markdown">```Javapackage site.wendev.hello;public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello, World!&quot;);    &#125;&#125;​```</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;pre&gt;package site.wendev.hello;public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello, World!&quot;);    &#125;&#125;&lt;/pre&gt;</code></pre><p>效果：</p><pre><code class="Java">package site.wendev.hello;public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello, World!&quot;);    &#125;&#125;</code></pre><p>注意：有的Markdown编辑器会自动补全结束的三个`，比如Typora，但绝大多数都不会，需要你自己把它打上。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>这一种比较小众，打起来也比较麻烦，不过我刚入门的时候用的是这一种打法。</p><p>这种打法就是代码块所在的行前面先打四个空格，再打代码。Typora需要进入源代码模式才能打出来，相对来说Markdown Pad打这种会方便些。</p><p>例如：</p><pre><code class="markdown">    #include &lt;iostream&gt;    using namespace std;    int main() &#123;      cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;            return 0;    &#125;</code></pre><p>同样相当于HTML的<code>&lt;pre&gt;</code>标签。</p><p>效果：</p><pre><code>#include &lt;iostream&gt;using namespace std;int main() &#123;  cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>因为这种打法太麻烦了，也不便于代码的批量复制粘贴，所以不建议大家使用。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接以及接下来要说的图片可能对刚学的同学来说有点难理解，但是不用担心，对照着HTML来是很简单的。</p><p>超链接的打法是<code>[]()</code>，其中方括号内为超链接的文字，圆括号内是超链接的地址。</p><p>注意这个方括号和圆括号都是英文的。</p><p>相当于HTML的<code>&lt;a&gt;</code>标签，圆括号里的是<code>&lt;a&gt;</code>标签的<code>href</code>属性，方括号里的是<code>&lt;a&gt;</code>标签的内容。</p><p>例如：</p><pre><code class="markdown">[我的简书](https://www.jianshu.com/u/dc63550214af)</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;a href=&quot;https://www.jianshu.com/u/dc63550214af&quot;&gt;我的简书&lt;/a&gt;</code></pre><p>效果：</p><p><a href="https://www.jianshu.com/u/dc63550214af">我的简书</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片就是超链接前加上一个英文的<code>!</code>。方括号内为图片的图注，圆括号内为图片的网络地址或者本地地址。</p><p>相当于HTML的<code>&lt;img&gt;</code>标签，圆括号里的是<code>src</code>属性，方括号里的是<code>alt</code>属性。</p><p>例如：</p><pre><code class="markdown">![我的首页效果图](https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200417144101.png)</code></pre><p>相当于HTML：</p><pre><code class="html">&lt;img src=&quot;https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200417144101.png&quot; alt=&quot;我的首页效果图&quot;&gt;</code></pre><p>效果：</p><p><img src="https://gitee.com/QNKCDZ0/pictures/raw/master/img/20200417144101.png" alt="我的首页效果图"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格是最复杂的，也是最劝退新人的，所以我们放在最后来讲。不过没关系，掌握了以后你也可以很轻松地打出来。</p><p>表格相当于HTML的<code>&lt;table&gt;</code>。</p><p>因为表格的组成比较复杂，我们分块来讲。</p><p>表格的打法有很多种，这里介绍我最常用的一种。</p><p>注意：表格也要跟正文之间空出一行。</p><h3 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h3><p>表头的打法是：</p><pre><code class="markdown">thead|thead|thead-----|-----|-----</code></pre><p>相当于HTML的<code>&lt;thead&gt;</code>。</p><p>上面的打法相当于HTML的：</p><pre><code class="html">&lt;thead&gt;    &lt;tr&gt;    &lt;td&gt;thead&lt;/td&gt;    &lt;td&gt;thead&lt;/td&gt;    &lt;td&gt;thead&lt;/td&gt;  &lt;/tr&gt;&lt;/thead&gt;</code></pre><p>表头的第一行是表头的内容，相互之间用<code>|</code>分隔开，<code>|</code>的个数是表格的列数减1。</p><p>然后紧接着一行是<code>-</code>与<code>|</code>的组合，就是将第一行表头的内容换成<code>-</code>，几个都可以，这一行是表头与表格内容的分界线。</p><h3 id="表格内容"><a href="#表格内容" class="headerlink" title="表格内容"></a>表格内容</h3><p>表格内容的打法与表头一样，都是：</p><pre><code class="markdown">tbody|tbody|tbodytbody|tbody|tbody</code></pre><p>两列之间用一个<code>|</code>分隔开，行之间没有分隔符，也不用多打空格来换行。</p><p>相当于HTML的<code>&lt;tbody&gt;</code>。</p><p>上面的写法相当于HTML的：</p><pre><code class="html">    &lt;tbody&gt;      &lt;tr&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;</code></pre><p>综上所述，整个表格的打法为：</p><pre><code class="markdown">thead|thead|thead-----|-----|-----tbody|tbody|tbodytbody|tbody|tbody</code></pre><p>相当于HTML的：</p><pre><code class="HTML">&lt;table&gt;  &lt;thead&gt;        &lt;tr&gt;        &lt;td&gt;thead&lt;/td&gt;        &lt;td&gt;thead&lt;/td&gt;        &lt;td&gt;thead&lt;/td&gt;      &lt;/tr&gt;    &lt;/thead&gt;  &lt;tbody&gt;      &lt;tr&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;        &lt;td&gt;tbody&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>效果：</p><table><thead><tr><th>thead</th><th>thead</th><th>thead</th></tr></thead><tbody><tr><td>tbody</td><td>tbody</td><td>tbody</td></tr><tr><td>tbody</td><td>tbody</td><td>tbody</td></tr></tbody></table><p>注意：</p><p>似乎有些Markdown编辑器不认表格，也不知道是怎么回事。。。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文看懂Web后端开发</title>
      <link href="/2021/11/22/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
      <url>/2021/11/22/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一文看懂Web后端开发"><a href="#一文看懂Web后端开发" class="headerlink" title="一文看懂Web后端开发"></a>一文看懂Web后端开发</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于网络上系统地介绍后端开发的文章实在太少，而最近有恰巧有许多同学问我“什么是后端开发？”、“你为什么喜欢后端开发？”、“做后端都需要学什么？”，那么我们就来讲一讲，到底什么才是后端开发。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>后端开发</strong>（<code>Back-End Development</code>，也称<strong>服务端开发</strong>、<strong>服务器端开发</strong>等）是创建完整可运行的Web应用服务端程序（服务端程序和资源合称为<strong>后端</strong>，即在服务器上运行的、不涉及用户界面的部分）的过程，是Web应用程序开发的一部分。后端开发者使用<code>Java</code>、<code>Golang</code>等语言及其衍生的各种框架、库和解决方案来实现Web应用程序的核心业务逻辑，并向外提供特定的API，使得Web应用能够高效、安全、稳定地运行。</p><h2 id="说人话！"><a href="#说人话！" class="headerlink" title="说人话！"></a>说人话！</h2><p>好吧，如果你看了定义仍然很懵，那我就用一些非常易于理解的表达形式来说一说“什么是后端开发”。虽然这些表述可能并不严谨或完全正确，但是我相信这样一定能使你明白什么是后端开发。</p><p>这里我们拿前端来类比一下，因为我相信绝大多数看到这篇文章的人都已经对“什么是前端开发”、“什么是前端”有一定了解了：</p><ol><li>前端就相当于我们的肉体，后端就相当于我们的灵魂和思想；</li><li>前端是如何操作游戏，后端是具体的游戏规则；</li><li>前端是用户能看到的，后端是用户看不到的；</li><li>前端是跑在浏览器上的，后端是跑在服务器上的；</li><li>前端采集用户的输入，后端处理用户的输入；</li><li>前端开发是写代码给用户看，后端开发是写代码给服务器看。</li></ol><p>是不是这样一讲就明白了？那我们接着往下看。</p><h2 id="具体职责"><a href="#具体职责" class="headerlink" title="具体职责"></a>具体职责</h2><ol><li><strong>实现Web应用程序的实际业务逻辑。</strong>即：实现Web应用程序的具体功能（如注册、发表和查询信息等）或Web应用程序在服务端执行的具体操作。这是后端开发这项工作的主要内容；</li><li><strong>使用API和创建API。</strong>后端需要向前端提供前端所需的数据，也需要使用第三方API来完成业务逻辑（如完成某个功能需要通过API调用其他应用、在使用框架进行开发时需要使用语言和框架的API、操作数据库时需要使用数据库或ORM框架的API等）。因为在后端开发的过程中经常需要与API打交道，所以有人也把后端开发称为“API开发”，就像有些人将前端称为“GUI开发”一样；</li><li><strong>优化。</strong>在用户量达到一定程度后，就会出现诸如响应慢等各种问题（不理解的话想想你们大学的选课系统）；同时，随着代码行数的增多，许多架构上的缺陷可能也会随之暴露出来，如代码逻辑混乱、模块划分不正确等。此时就需要后端开发人员对Web应用程序进行优化，如重构、分布式部署、优化业务逻辑、单体应用拆分成微服务等；</li><li><strong>架构设计。</strong>虽然一般只有高级的后端开发人员和架构师才需要关注架构问题，但是架构设计是后端开发中非常重要的一环，因为它决定了如何组织代码、某个模块负责解决什么样的问题、系统的扩展性和可维护性如何、业务逻辑如何进行组织等，也会一定程度上影响到业务逻辑的具体实现（比如微服务和单体架构这两种架构下，同一种业务逻辑的实现可能完全不同）。</li></ol><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>后端是工作在服务器上的，负责通过API向前端或其他系统提供其所需的信息（如数据等）；</li><li>后端开发实际上是开发Web应用中对用户不可见的部分（如核心业务逻辑、数据库等），大多数的后端开发都是不涉及用户界面的（除了在前后端不分离的架构中将前端的静态页面通过模板引擎改造成动态页面时）；</li><li>通常情况下，一个Web应用的绝大多数代码都属于后端代码，因为后端承担了Web应用实际的业务逻辑；</li><li>后端开发的压力通常比前端开发要大，因为后端是Web应用的“灵魂”，它影响着Web应用的方方面面，除了业务逻辑之外还需要考虑安全性、稳定性、可维护性、可扩展性、伸缩性等问题。</li></ol><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ol><li><strong>程序设计语言</strong>。许多语言都可以用于后端开发，比较流行的是<code>Java</code>和<code>Go</code>。例如我所使用的就是Go语言，也曾经使用过Java。此外，由于后端开发中经常需要和数据库打交道，所以作为后端开发者，还需要懂<code>SQL</code>语言（如果使用了<code>NoSQL</code>的话，也需要懂<code>NoSQL</code>数据库的语言）；</li><li><strong>数据库</strong>。数据库作为一种简单易用的持久化机制，可以让用户的信息不因为断电等故障而丢失，Web应用开发中经常需要用到数据库，甚至许多简单的Web应用本质上都只是“数据库的可视化系统”，也因为绝大多数简单的业务逻辑本质上都只是对数据库的增删改查（即<code>CRUD</code>）；</li><li><strong>框架、库和解决方案</strong>。想要高效率地开发Web应用，框架、库和解决方案是必不可少的，比如MVC框架、ORM框架、RPC框架、微服务开发框架、云基础设施（如Service Mesh、容器编排工具等）、运行时环境/容器（如Docker）、消息队列（Message Queue，MQ）、日志收集和分析工具等；这部分有一些框架是可以跨语言通用的，比如<code>gRPC</code>（RPC框架）、<code>Istio</code>（Service Mesh），也有一些是某种语言专用的，如<code>Spring Cloud</code>（微服务开发工具，JVM技术栈专用）、<code>Gin</code>（MVC框架，Go语言专用）；</li><li><strong>架构和指导思想</strong>。架构是后端开发中非常重要的一部分，作为一名后端开发者需要了解常见的架构，如三层架构、SOA、微服务架构、六边形架构等，还需要了解常用于后端开发中的指导思想，如设计模式、MVC模式、DDD、CQRS/ES等；</li><li><strong>包管理工具/项目管理工具</strong>。因为后端开发中经常要用到各种框架和库，所以用于管理这些框架和库的管理工具是非常重要的。每一门语言都有自己的包管理工具，如Java的<code>Maven</code>，Go语言的<code>go mod</code>等；</li><li><strong>基础知识</strong>。不管是前端开发还是后端开发，都需要对操作系统、计算机网络、数据结构等基础知识有一定了解，还需要了解对应语言的编码规范、重构等知识，这可以帮助你理解框架和库，也能帮助你写出更高质量的代码；</li><li><strong>开发方法</strong>。实际上这个也可以说是属于指导思想的一部分，包括CI/CD、敏捷开发、DevOps等；</li><li><strong>版本管理工具</strong>。相信我，几乎没有人能离开这玩意。最常用的是<code>Git</code>。</li></ol><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><p>有不少人其实对后端开发误解很深，以下是一些常见的误解：</p><ol><li>后端开发就是CRUD/后端开发太简单了；</li><li>不同系统的后端面临的问题高度相似；</li><li>后端开发很枯燥；</li><li>后端的逻辑比前端复杂；</li><li>对于后端开发者来说，设计业务逻辑是一件很简单的事情；</li><li>后端开发的工作太单一了/后端不是一个综合的领域；</li></ol><p>这些误解有时候会劝退一些有意从事后端开发的同学，我们现在就来澄清一下这些误解：</p><ol><li>我不否认很多简单的Web应用确实就是CRUD，但是绝大多数的Web应用都不仅仅是CRUD。至于“太简单了”，能说出这话的人一定没做过后端，或者只做过CRUD，或者是超级大牛。如果不是超级大牛的话，请说这话的人写一个能撑住五万并发的秒杀系统出来，并做压力测试，然后再看看这句话；另外，后端开发是一个非常综合的领域，既有非常抽象的架构和指导思想，又有具体的解决方案和业务逻辑，还涉及到许多计算机底层问题（如多线程、网络、I/O等）。并且，虽然后端技术稳定，但也不至于学了点东西就可以到哪里都通吃，例如，如果你没听说过云原生、微服务、Serverless等新技术的话，那说明你已经很久没有跟上后端技术的发展了；以及，如果你现在还在用JSP，那我敢肯定你一定没有意识到诸如前后端分离之类的新问题；</li><li>这个说法也完全不对。不同的系统所面临的具体问题是完全不同的。先不说对一个具体的需求可能有很多种不同的解决方案（如针对单点登录（Single Sign On，SSO）问题就有长连接（虽然我没见过落地案例）、共享Session、JWT等方案），有时候甚至当你拿到一个需求时，可能连要解决什么问题都搞不清楚，这也就是为什么诸如DDD这样的系统分析方法一直备受关注，且重构也经常在各种规模的Web应用中都引起重视，因为用户需求往往不是那么明确，可能会引导我们做出错误的设计；</li><li>记住，<strong>枯燥的是CRUD，而不是后端</strong>。后端开发的技术含量实际上是非常高的，也非常有意思，充满了未知与挑战。像微服务、云原生、DDD、CQRS/ES、高并发、负载均衡、缓存、消息队列、多线程、微服务监控、Service Mesh等技术，每一项都值得我们去研究，而这些技术中有很多都是在大型Web应用中被频繁使用的，如果你真正了解后端开发的话，是绝无可能说出“后端开发很枯燥”这样的话的。请记住，并不是不涉及界面的工作就一定很枯燥；</li><li>在大多数的系统中是这样的，但是有些Web应用的前端逻辑复杂程度可能不亚于后端，甚至可能还会超过后端，比如像石墨文档这样的多人协作文档系统，还有ProcessOn这样的在线绘图系统，其前端逻辑可能都是非常复杂的；</li><li>参见2。能说出这话的人一定没重构过一个“大泥球”一样的应用，也没设计过一个用户需求非常模糊的系统（比如用户只给了一条需求：做一个CMS（内容管理系统），你觉得简单你可以来试试，然后用它一个月，如果你不是个有经验的后端开发者的话，我相信你一定会被你自己所写的这个系统逼疯，恨不得将它完全重构）；</li><li>参见1和2。如果后端开发还不综合的话，那什么才是综合的呢？</li></ol><p>我不否认做一个只会CRUD的后端开发者很简单，但既然对后端开发感兴趣，那我们就要有更高的志向，不能把自己框死在CRUD里。</p><p>这里送给各位未来的后端开发者一句话：“<strong>我等采石之人，当心怀大教堂之愿景</strong>”。如果自己一个人完成一个简简单单的CRUD项目，你可以有自己的想法，例如在其中应用DDD和CQRS，或不断地优化它以达到最佳状态；如果迫于工作经验而不得不CRUD，你也可以用业余时间去提升自己的技术，让自己有更光明的未来。</p><h2 id="什么样的人适合做后端？"><a href="#什么样的人适合做后端？" class="headerlink" title="什么样的人适合做后端？"></a>什么样的人适合做后端？</h2><p>说了这么多，那什么样的人才适合做后端开发这份工作呢？</p><ol><li><strong>讨厌写用户界面或与用户界面打交道的人</strong>。有很多人是因为讨厌写界面（尤其是CSS这种反人类的东西）才来做后端开发的。这里没有界面，讨厌与用户界面打交道的人不妨尝试一下后端开发；</li><li><strong>细心的人</strong>。后端开发实际上比前端开发更需要细心。就如前文所述，后端是Web应用程序的“灵魂”，后端开发中的许多问题都决定着Web应用的“生死存亡”，尤其是<strong>数据校验</strong>、<strong>多线程/多进程</strong>、<strong>锁</strong>、<strong>异步编程</strong>、<strong>事务/分布式事务</strong>、<strong>与第三方系统的交互</strong>等，这些问题有非常非常多的细节，且既复杂又非常重要，一旦在细节上出现问题（如数据校验不完全或加锁解锁的逻辑出现错误），轻则出现错误的数据或业务逻辑不能正常运行，重则直接导致整个Web应用挂掉或出现安全问题（如数据校验不完全导致的文件上传漏洞、函数使用错误导致的远程命令执行漏洞等）。所以如果你想从事后端开发，那足够细心绝对是一个必要的条件；</li><li><strong>喜欢与机器打交道多于与人打交道的人</strong>。与前端开发是“写代码给人看”的不同，后端开发是“写代码给服务器看”（或者说给前端/第三方系统看）的。虽然这两个说法都不太严谨，但是后端开发更多的就是与服务器打交道（如降低资源使用率、提高Web应用程序的运行效率等等），而不是与人打交道（如提高页面的美观程度、思考用户的使用逻辑和心理等等）；</li><li><strong>想编写实际的业务逻辑的人，或喜欢算法和逻辑的人</strong>。前端的逻辑更多的是交互逻辑，如点击某个按钮应该弹出什么窗口、怎么把数据渲染成用户想要看到的页面等，而后端的逻辑更多的是实际的业务逻辑，如完成某个功能需要怎样做、请求某个API应该返回什么样的数据等。如果你和我一样写前端时因为总是接触不到实际的业务逻辑而感到不爽，那么大后端欢迎你；</li><li><strong>好奇心强、自学能力强且有终身学习的觉悟的人，或者喜欢钻研技术的人，或喜欢充满挑战性的工作的人</strong>。后端看似简单，实际上技术含量是非常高的。就如前面所说，现在的后端可不仅仅是CRUD，而是随着互联网和云计算技术的发展而不断改变，Web应用程序在需求不断变化的过程中功能变得越来越强，架构变得越来越复杂，对性能的考验也越来越严峻，技术含量自然也就越来越高。作为一名后端开发工程师，需要有不断学习新技术的觉悟，还需要有一定的自学能力，因为不是什么技术都有人教你的，在学习和使用最新技术时对着英文文档啃是常有的事；</li><li><strong>对系统架构感兴趣或想要成为架构师的人</strong>。虽然不可否认的是由于前端至今没有“一统天下”的解决方案而使得前端开发人员经常会比后端开发人员更早地接触到架构的部分，但是传统意义上的前端说白了也就是浏览器那“一亩三分地”（前端同学别喷我，这里仅仅说的是传统的Web前端，“大前端”是不算的哈），而后端技术的天花板则是“地球上人类的数量”（接触过高并发的同学看到这句话应该很有感触吧，哈哈），而核心的业务逻辑往往存在于后端，后端的优化压力往往比前端更大，这就使得初级的后端开发者在进行开发时需要对系统的架构有一定了解、高级的后端开发者需要经常思考系统的架构设计的问题，这也使得后端开发者更容易成长为架构师；</li><li><strong>沉得住气的人</strong>。除了有第5条中提到的“后端的技术含量实际上是非常高的”这一原因之外，还有一个原因就是后端并不是“所见即所得”的，经常需要你编写几十甚至几百行代码、做无数复杂的配置才能把Web应用运行起来（注意，是运行，写业务逻辑的话需要更多代码），另一个原因是后端开发的门槛比前端要高——你至少得掌握一门语言和这门语言在后端开发方面的一些框架或库才能开始开发。所以，后端开发者必须要沉得住气，不能因为写几行代码看不到任何效果就想放弃；</li><li><strong>对系统的基础设施（如框架、库和解决方案等）感兴趣的人</strong>。据我所知，许多在云原生方面有深刻造诣的大佬都是从后端开发者成长起来的，许多框架的作者曾经也是后端开发者。如果你碰巧像我一样对框架、库和解决方案（如<code>Spring Boot</code>、<code>Spring Cloud</code>、<code>Gin</code>、<code>Kubernetes</code>、<code>Istio</code>等）十分感兴趣，那么可以从成为一名后端开发者开始，在编写业务代码的过程中慢慢体会框架的重要性和所用框架的优缺点，以及如何设计一个好的框架。</li></ol><p>虽然你并不需要满足以上每一项才能成为一个后端开发工程师，但是如果你发现你满足上面的某一条或某几条，而且你还没有找到自己的方向，那么不妨来尝试一下后端开发。</p><h2 id="我为什么喜欢后端开发"><a href="#我为什么喜欢后端开发" class="headerlink" title="我为什么喜欢后端开发"></a>我为什么喜欢后端开发</h2><p>先简单介绍以下我的经历吧。我从2019年1月开始接触前端开发，于2019年8月正式转向后端开发，并一直从事后端开发至今。我喜欢后端开发的原因，其实很简单：</p><ol><li>我反感写界面，痛恨GUI编程，每次一写界面我就想遁地。后端开发不需要考虑界面的问题，这里没有界面，只有API；</li><li>我喜欢写实在的业务逻辑，不想总是隔着个API而“任人摆布”，解决实际问题对我来说简直棒极了；</li><li>我喜欢与机器打交道，可以写一天的代码而不感到无聊，但我不喜欢与人打交道，尤其是面对面交谈非技术问题时总会感到不自然（当然，聊技术我能聊一天都不嫌烦）；</li><li>我想要成为一名架构师，想成就优秀的设计，而后端开发能更多地接触到系统的架构和设计；</li><li>接触到后端开发后，我发现我对这一领域内的绝大多数事物都感兴趣，如云原生、DDD、Service Mesh、系统架构等；</li><li>写前端会让我感到痛苦万分，因为我审美诡异、不擅长思考用户的使用逻辑、不擅长编写交互逻辑，写出来的东西又丑又反人类。而当我开始写后端时，我发现我的思考方式经常和真实的业务逻辑出奇地一致，有时候还能在做项目的过程中发现当前所使用的工具的不足，并且思考如何才能设计得更好；</li><li>做后端开发做了一年左右，我越来越感觉到我喜欢这份工作。</li></ol><p>如果你也和我有一样的想法，那么你说不定也非常适合从事后端开发的工作。大后端欢迎你的到来。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多人对后端开发的误解源于缺少一篇系统地介绍后端开发的文章。虽然作为一个仅仅入行一年半（截止到2021年3月）的菜鸟，我对后端开发的理解肯定还有许多不足与偏颇，这篇文章也并不那么“系统”，但我仍希望这篇文章能帮助到其他同学了解后端开发或消除对后端开发的误解，抑或找到自己的方向而走上后端开发这条路。</p><p>如果发现文中的错漏之处，欢迎发表评论或联系我进行改正。希望能帮到更多对后端开发感兴趣的同学。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
